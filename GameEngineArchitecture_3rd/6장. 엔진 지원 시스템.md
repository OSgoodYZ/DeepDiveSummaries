# 6장. 엔진 지원 시스템

게임 엔진은 엔진의 시작과 종료, 메모리 사용 관리, 파일 시스템 접근, 게임 자원 처리 지원, 개발 팀을 위한 디버깅 시스템 제공 등 다양한 **로우레벨 지원 시스템**으로 구성된 복잡한 소프트웨어입니다. 이 장에서는 대부분의 게임 엔진에서 볼 수 있는 이러한 로우레벨 지원 시스템에 대해 자세히 다루며, 이는 엔진의 안정성과 성능에 직결되는 중요한 요소들입니다.

---

### 6.1 하부 시스템 시작과 종료

게임 엔진은 수많은 **하부 시스템**이 모여 이루어진 복잡한 소프트웨어이며, 엔진을 시작할 때 각 하부 시스템을 **정해진 순서**에 따라 설정하고 초기화해야 합니다. 이 시작 순서는 하부 시스템 간의 **의존성 관계**에 따라 결정되며, 예를 들어 하부 시스템 B가 A에 의존한다면 A를 먼저 시작한 후에 B를 초기화해야 합니다. 종료 시에는 대개 이 순서의 **정반대**로, B가 먼저 종료되고 A가 그 다음으로 종료됩니다.

*   **6.1.1 C++ 전역 초기화 순서 (또는 그 부재에 관해)**
    C++에서는 `main()` 또는 `WinMain()` 함수가 호출되기 전에 **전역 객체와 정적 객체를 생성**하지만, 이 객체들의 생성 순서는 **완전히 임의적**입니다. 따라서 상호 의존성이 있는 엔진 하부 시스템을 초기화하고 종료하는 데에는 전혀 쓸모가 없습니다. 게임 엔진의 주요 하부 시스템이 **싱글턴** 또는 **매니저 클래스**로 디자인되는 경우가 많다는 점을 고려할 때, C++의 이러한 제어 불가능성은 아쉬운 점입니다. 생성과 파괴 순서를 제어할 수 없기 때문에 전역으로 싱글턴 인스턴스를 정의하여 동적 메모리 할당 없이 매니저를 제어하는 방식은 사용할 수 없습니다.
    *   **6.1.1.1 주문형 생성 기법**
        C++에는 함수 안에서 선언된 정적 변수가 해당 함수가 처음 호출될 때 생성된다는 점을 이용한 '트릭'이 있습니다. 이를 통해 전역 싱글턴 객체를 함수의 정적 변수로 만들면 생성 순서를 제어할 수 있다고 합니다. 예를 들어, `RenderManager::get()` 함수가 호출될 때 `sSingleton` 객체가 생성되고, 이 생성자 안에서 의존하는 다른 매니저들의 `get()` 함수를 호출하여 먼저 시작하게 할 수 있습니다. **그러나 이 방식은 여전히 파괴 순서를 제어할 수 없으며**, `get()` 함수가 언제 호출될지 예측할 수 없어 싱글턴의 생성 시점도 불확실합니다. 또한, 단순해 보이는 함수 안에서 덩치 큰 싱글턴을 생성하고 초기화하는 등의 시간이 걸리는 작업이 일어날 것이라고 프로그래머가 예상하지 못할 가능성도 있습니다. 따라서 이 방식은 **예측이 불가능하고 위험한 디자인**으로 간주됩니다.

*   **6.1.2 간단하고 제대로 된 방법**
    하부 시스템을 구현하는 데 싱글턴 매니저 개념을 계속 사용하더라도, 가장 간단하고 제대로 된 접근 방식은 각 매니저 클래스에 **`startUp()`과 `shutDown()` 함수를 명시적으로 정의**하는 것입니다. 이 함수들이 매니저의 시작과 종료를 실제로 담당하며, 생성자와 파괴자는 아무것도 하지 않도록 합니다. 이제 **`main()` 함수(또는 전체 엔진을 시작하는 객체 안에서) 안에서 이 시작과 종료 함수들을 원하는 순서대로 명시적으로 호출**하면 됩니다.
    이 방식은 다음과 같은 장점이 있습니다:
    *   **단순하고 구현하기 쉽습니다.**
    *   **명확합니다.** 코드를 보기만 하면 바로 시작 순서를 알 수 있습니다.
    *   **디버깅하고 유지하기 쉽습니다.** 제때 시작이 안 되거나 너무 일찍 시작되는 것이 있으면 코드 한 줄만 이동하면 됩니다.
    이 방식의 사소한 단점은 시작 순서의 정확한 역순으로 종료하지 않는 실수를 할 가능성이 있다는 점이지만, 이는 쉽게 대처할 수 있습니다. 중요한 것은 하부 시스템을 제대로 시작하고 종료하는 것입니다.

*   **6.1.3 실제 게임 엔진의 예**
    *   **6.1.3.1 오거 (Ogre)**
        오거는 렌더링 엔진이지만 완전한 게임 엔진에서 볼 수 있는 로우레벨 기능도 제공합니다. 오거의 시작/종료 기능은 **`Ogre::Root` 싱글턴 객체**에 의해 제어됩니다. `Root` 객체는 오거의 모든 주요 하부 시스템에 대한 포인터를 가지고 있으며, 이들의 생성과 파괴를 관리합니다. 코드를 통해 오거를 시작하는 것은 **`Ogre::Root`를 `new` 연산자로 생성하기만 하면 모든 초기화가 이루어지므로** 매우 간단합니다. 오거는 `Ogre::Singleton` 템플릿을 사용하여 모든 싱글턴(매니저) 클래스가 이를 상속하도록 설계되었습니다. `Ogre::Root`는 **지연된 생성(lazy instantiation)을 사용하지 않고 각 싱글턴을 명시적으로 생성(`new`)**하는데, 이는 싱글턴들이 분명하게 정해진 순서대로 생성되고 파괴되도록 하기 위함입니다.
    *   **6.1.3.2 너티 독의 언차티드와 라스트 오브 어스 시리즈**
        너티 독의 언차티드와 라스트 오브 어스 시리즈 엔진도 하부 시스템을 시작하는 데 **명시적인 방식**을 사용합니다. 엔진 초기화 과정에서는 다양한 운영체제 서비스 및 외부 라이브러리를 시작해야 합니다. 또한, 동적 메모리 할당을 가능한 한 피하고자 **`g_fileSystem`, `g_languageMgr`와 같은 정적 할당되는 싱글턴 객체들이 많습니다**. 이들은 `Init()` 함수를 명시적으로 호출하여 초기화됩니다. 코드가 시각적으로 매우 깔끔해 보이지는 않을 수 있지만, 문제없이 제 역할을 수행합니다.

---

### 6.2 메모리 관리

소프트웨어 성능은 알고리듬의 효율성과 코딩 방식 외에도 프로그램이 **메모리를 얼마나 잘 활용했는지**에 크게 영향을 받습니다. 메모리가 성능에 영향을 미치는 방식은 두 가지입니다:
1.  **동적 메모리 할당(`malloc()` 또는 C++의 전역 `new` 연산자)은 매우 느립니다**.
2.  **메모리 접근 패턴(`memory access pattern`)**은 성능에 큰 영향을 미칩니다. 같은 데이터라도 작고 연속적인 메모리 블록에 들어 있는 경우가 넓은 메모리 주소에 흩뿌려져 있는 경우보다 CPU 캐시에서 처리 속도가 훨씬 빠릅니다.
동적 메모리 할당이 느린 주된 이유는 **범용 목적**이라 관리 비용이 들고, 대부분의 운영체제에서 **사용자 모드에서 커널 모드로 콘텍스트 전환**이 필요하기 때문입니다. 게임 개발에서는 "힙 할당은 최소화하고 타이트 루프 안에서는 절대 힙 할당을 하지 말 것"이 널리 통용되는 금언입니다.

*   **6.2.1 힙 메모리 할당 최적화**
    게임 엔진은 동적 메모리 할당을 완전히 피하기 어렵기 때문에, 대부분의 게임 엔진은 여러 가지 **자체 제작 할당자(Custom Allocators)**를 구현합니다. 자체 제작 할당자는 미리 할당된 메모리 블록을 사용하므로 운영체제의 커널 모드로 전환할 필요 없이 **유저 모드에서만 동작**하며, 사용 패턴을 예측할 수 있어 범용 힙 할당자보다 훨씬 효율적입니다.
    *   **6.2.1.1 스택 기반 할당자**
        게임에서 **LIFO(Last-In, First-Out)** 방식으로 메모리를 할당하는 데 사용됩니다. 구현하기 쉽고, 크고 연속적인 메모리 블록을 할당하기만 하면 됩니다. 가장 근래에 할당한 블록을 해제할 때는 꼭대기 포인터를 블록 크기만큼 아래로 내리는(롤백) 방식으로 동작합니다. 스택 할당자를 사용할 경우 **임의의 할당된 메모리를 해제할 수 없으며, 해제는 반드시 할당의 역순으로 수행**해야 합니다. 대신 스택의 현재 꼭대기를 표시하는 마커를 리턴하고, 이 마커를 인자로 받아 이전 위치로 롤백하는 `freeToMarker()` 함수를 사용합니다.
        **끝이 2개인 스택 할당자**는 하나의 메모리 블록에서 하나는 아래에서부터, 다른 하나는 위에서부터 메모리를 할당하여 더 효율적으로 메모리를 활용할 수 있게 합니다. 미드웨이의 '하이드로 선더' 게임은 이 방식을 성공적으로 사용하여 메모리 단편화 문제를 겪지 않았습니다.
    *   **6.2.1.2 풀 할당자**
        게임 엔진 프로그래밍에서 작은 **고정 크기**의 메모리 블록을 여러 개 할당/해제하는 데 최적입니다. 행렬, 반복자, 연결 리스트의 노드, 메시 인스턴스 등 작은 고정 크기 객체 할당에 자주 사용됩니다. 풀 할당자는 개별 원소들의 크기에 정확히 배수가 되는 큰 메모리 블록을 할당한 후, 이 블록을 **사용 가능 리스트(free list)**로 관리합니다. 할당과 해제 모두 포인터 처리 몇 개만 필요하므로 **O(1) 상수 시간**에 이루어지며, 단편화가 발생하지 않습니다. 사용 가능 리스트는 각 원소 내에 다음 원소를 가리키는 포인터를 저장하여 메모리를 효율적으로 사용합니다.
    *   **6.2.1.3 정렬된 할당자**
        모든 변수와 데이터 객체에는 특정 **메모리 정렬 요구사항(`alignment requirement`)**이 있습니다. (예: 32비트 정수는 4바이트 정렬, 128비트 SIMD 벡터는 16바이트 정렬). PS3의 DMA 같은 경우 128바이트 정렬을 지켜야 처리량을 극대화할 수 있습니다. 정렬된 할당자는 요청된 것보다 조금 큰 메모리를 할당하고, 블록의 주소를 살짝 시프트하여 정렬을 맞춘 후 조정된 주소를 리턴합니다. 메모리 해제 시에는 시프트가 적용된 주소를 받게 되므로, 원래 할당받은 주소를 되돌릴 방법이 필요합니다. 한 가지 간단한 방법은 시프트 값을 해제 함수에서 접근할 수 있는 어딘가에 저장하는 것입니다. 예를 들어, 할당된 메모리 블록 바로 앞 1바이트 공간에 시프트 값을 저장하는 방식으로 구현할 수 있습니다.
    *   **6.2.1.4 단일 프레임과 이중 버퍼 메모리 할당자**
        게임 루프 도중에 발생하는 **임시 데이터 할당**을 위해 사용됩니다.
        *   **단일 프레임 할당자**: 스택 할당자 형태로 구현되며, **매 프레임이 시작될 때 스택의 '꼭대기' 포인터가 메모리 블록의 가장 아래로 초기화(`clear()`)**됩니다. 따라서 할당된 메모리를 명시적으로 해제할 필요가 없으며, 매우 빠릅니다. 주요 단점은 할당된 메모리 블록이 **현재 프레임 내에서만 유효**하다는 점을 프로그래머가 항상 주의해야 하며, 프레임이 넘어가게 캐시해서는 안 됩니다.
        *   **이중 버퍼 할당자**: 같은 크기의 단일 프레임 버퍼 두 개를 번갈아 사용하는 방식입니다. `swapBuffers()` 함수로 활성 버퍼와 비활성 버퍼를 바꾸고 `clearCurrentBuffer()`로 현재 활성화된 버퍼만 초기화합니다. 이런 형태의 할당자는 엑스박스 360이나 플레이스테이션 3과 같은 **멀티코어 콘솔에서 비동기적으로 처리한 결과를 캐시하는 데 굉장히 유용**합니다. 예를 들어, N번째 프레임에 비동기 작업을 시작하고 그 결과를 N+1 프레임에서 사용할 버퍼에 저장하도록 할 수 있습니다.

*   **6.2.2 메모리 단편화**
    동적 힙 할당자의 또 다른 문제는 시간이 지남에 따라 **메모리 단편화(`memory fragmentation`)**가 일어난다는 점입니다. 이는 메모리에 빈 공간들이 조각조각 흩어져 할당 가능한 연속적인 블록이 부족해지는 현상으로, 빈 공간이 충분히 있는데도 불구하고 메모리 할당이 실패할 수 있습니다. 문제의 핵심은 할당된 메모리 블록이 항상 연속적이어야 한다는 점입니다. 가상 메모리를 지원하는 운영체제도 있지만, 대부분의 콘솔 게임 엔진들은 가상 메모리가 갖는 본질적인 성능 저하 때문에 가상 메모리를 잘 활용하지 않습니다.
    *   **6.2.2.1 스택 할당자와 풀 할당자로 단편화 예방**
        **스택 할당자**는 항상 연속적으로 할당되고 블록을 해제할 때 할당 순서의 반대로 해야 하므로 **메모리 단편화를 겪지 않습니다**. **풀 할당자**도 마찬가지로 **단편화를 겪지 않습니다**. 블록 자체는 단편화될 수 있지만, 모든 블록의 크기가 같기 때문에 연속된 공간이 부족해 할당이 실패하는 경우는 없습니다.
    *   **6.2.2.2 조각 모음과 재배치**
        크기가 제각각인 객체들을 사용해야 하는 경우, 힙의 메모리 블록을 재배치하여 단편화를 해소하는 **조각 모음(`defragmentation`)**이 필요합니다. 조각 모음은 힙에 흩어져 있는 빈 '구멍'들을 하나로 합치는 과정으로, 할당된 블록들을 낮은 메모리 주소로 이동시켜 구멍들을 높은 메모리 주소에 모아 하나의 커다란 구멍을 형성합니다. 이 과정에서 **포인터 재배치(`pointer relocation`)**가 필수적입니다. 이동하는 메모리 블록을 가리키는 포인터들을 모두 찾아 새로운 주소로 업데이트해야 하는데, 이를 위해 프로그래머가 포인터들을 일일이 관리하거나, **스마트 포인터**나 **핸들** 같은 재배치에 더 적합한 도구를 사용해야 합니다.
        *   **스마트 포인터**: 포인터를 포함하는 작은 클래스로, 메모리 재배치를 처리하도록 코드를 짤 수 있습니다.
        *   **핸들**: 포인터가 담긴 테이블 내의 번호로 구현되며, 이 테이블은 재배치가 되지 않습니다. 핸들은 포인터 테이블 내의 인덱스일 뿐이므로 메모리 블록이 이동되더라도 핸들 자체는 변하지 않아 메모리 재배치에 영향을 받지 않습니다.
        조각 모음은 메모리 블록을 복사해야 하므로 굉장히 느릴 수 있습니다. 하지만 **힙 전체를 한꺼번에 조각 모음할 필요 없이 여러 프레임에 걸쳐 그 비용을 분산**시킬 수 있습니다. 너티 독의 엔진들에서는 작은 게임 객체들만 재배치를 사용했으며, 이들은 수 킬로바이트를 넘는 경우가 없어 문제가 되지 않았습니다.

---

### 6.3 컨테이너

**컨테이너(`container`)** 또는 컬렉션(`collection`)은 여러 데이터 요소를 보관하고 관리하는 자료구조입니다. 배열, 동적 배열(벡터), 연결 리스트, 스택, 큐, 트리, 사전(해시 테이블), 그래프 등 다양하며, 각기 장단점을 가집니다.

*   **6.3.1 컨테이너 동작**
    컨테이너에는 삽입, 제거, 순차적 접근, 임의 접근, 검색, 정렬 등 다양한 동작들이 있습니다.
    **반복자(`Iterators`)**는 컨테이너의 요소에 효율적으로 접근하는 방법을 '알고 있는' 작은 클래스입니다. 반복자는 컨테이너 내부 구현과 클라이언트 코드를 분리하며, 순회 작업을 단순화합니다.
    *   **6.3.2.1 전치 증가와 후치 증가**
        C++에서 반복자를 증가시킬 때 **전치 증가(`++p`) 연산자를 후치 증가(`p++`) 연산자보다 우선하여 사용**하는 것이 좋습니다. 후치 증가 연산자는 증가하기 전의 값을 저장한 후 포인터/반복자를 증가시키고 마지막으로 저장한 값을 리턴하기 때문에, 임시 객체 생성 및 복사 비용이 발생할 수 있습니다. 포인터나 정수의 경우 문제가 되지 않을 수 있지만, 반복자의 경우 객체를 생성하고 복사하는 데 걸리는 시간을 무시할 수 없는 경우가 있어 성능상 전치 증가가 유리합니다.

*   **6.3.3 알고리듬 복잡도**
    컨테이너를 선택할 때는 컨테이너의 성능 및 메모리 특성을 고려해야 합니다. 어떤 연산이 수행되는 데 걸리는 시간 `T`를 원소 개수 `n`의 함수로 표현하며, 함수의 **차수(`order of magnitude`)**를 나타내는 데 **빅 오(`Big O`) 표기법**을 사용합니다 (예: `O(1)`, `O(log n)`, `O(n)`, `O(n log n)`, `O(n^2)` 등). 가장 자주 사용할 연산들의 성능 특성을 고려하여 컨테이너를 골라야 합니다.
    또한, **메모리 배열과 사용 특성**도 중요합니다. 예를 들어, 동적 배열(`std::vector`)은 메모리에서 연속적으로 저장되어 캐시 성능이 좋지만, 연결 리스트는 요소들이 메모리에 흩어져 있어 캐시 성능이 좋지 않을 수 있습니다. 반면, 원소 삽입 및 제거 속도가 최우선인 경우 연결 리스트가 더 빠를 수 있습니다.

*   **6.3.4 자체 구현 컨테이너 클래스 만들기**
    콘솔 게임 엔진이나 휴대폰/PDA 게임 엔진에서는 **자체적으로 구현한 컨테이너 자료 구조**를 제공하는 경우가 많습니다. 이는 다음과 같은 이유 때문입니다:
    *   **완전한 제어**: 자료 구조의 메모리 요구 사항, 알고리듬, 메모리 할당 시점과 방식 등을 제어할 수 있습니다.
    *   **최적화 기회**: 목표 콘솔의 하드웨어 특성에 맞춰 자료 구조와 알고리듬을 최적화하거나 엔진의 특정 용도에 맞게 세부 조정할 수 있습니다.
    *   **보완 가능**: STL 등의 외부 라이브러리에는 없는 알고리듬을 자체적으로 만들어 넣을 수 있습니다.
    *   **외부 의존성 제거**: 스스로 만든 코드는 다른 회사나 팀에 의존하지 않고 유지보수 및 디버깅이 용이하며, 문제가 생기면 즉시 수정할 수 있습니다.
    *   **병행 자료 구조 제어**: 직접 컨테이너를 구현한다면 멀티스레드(혹은 멀티코어) 시스템에서의 동시 접근에 대해 완전한 제어권을 가질 수 있습니다.
    *   **6.3.4.1 어떻게 구현할 것인가**
        컨테이너를 구현하는 데는 세 가지 선택지가 있습니다: **1) 필요한 자료 구조를 직접 만드는 것, 2) C++ 표준 라이브러리의 STL 컨테이너를 사용하는 것, 3) Boost 라이브러리를 활용하는 것**.
        *   **C++ 표준 라이브러리 (STL)**: 다양하고 강력한 컨테이너 클래스들을 지원하며, 안정적이고 완전히 이식 가능하다는 장점이 있습니다. 그러나 헤더 파일이 복잡하고 이해하기 어려우며, 범용적이어서 특수 목적 자료구조보다 느리거나 메모리를 더 많이 차지할 수 있습니다. 또한, 동적 메모리 할당을 빈번하게 사용하는데, 고성능을 요하고 메모리 제약이 있는 콘솔에서 이를 제어하는 것이 힘들다는 단점이 있습니다.
        *   **Boost**: C++ 표준 위원회 라이브러리 워킹 그룹 멤버들에 의해 창안된 오픈소스 프로젝트로, STL을 확장하고 보완하는 데 중점을 둡니다. STL에는 없는 수많은 유용한 기능을 지원하며, STL의 내재된 문제에 대한 대안을 제시하기도 합니다. 스마트 포인터 등 복잡한 기능을 훌륭히 처리하며 문서화가 잘 되어 있습니다. 하지만 일부 라이브러리는 크기가 큰 `lib` 파일로 빌드되기 때문에 소규모 프로젝트에 부적합할 수 있고, 버그 발생 시 사용자의 책임이며 구 버전과의 호환성 문제가 발생할 수 있습니다.
        *   **Folly**: 페이스북 엔지니어들이 만든 오픈소스 라이브러리로, C++ 표준 라이브러리와 Boost 라이브러리를 확장하는 데 중점을 두며 사용 편의성과 고성능 소프트웨어 개발에 주안점을 둡니다.
        *   **Loki**: C++ 템플릿 메타프로그래밍 라이브러리 중 가장 유명하고 강력한 라이브러리입니다. 런타임에 해야 할 일들을 컴파일러가 처리하게 만드는 아이디어를 기반으로 합니다. 매우 강력하고 유용하지만, 코드가 읽고 사용하기 힘들며 완전히 이해하기 어렵고, 일부 구성 요소의 기능이 컴파일러의 '부수 효과'에 의존하여 이식성이 좋지 않다는 실질적인 단점이 있습니다. 재미 삼아 쓸 만한 라이브러리는 아니지만, 그 개념(예: policy-based design)은 유용합니다.

*   **6.3.5 동적 배열과 메모리 할당**
    C형태의 고정 크기 배열은 메모리 할당 비용이 없고, 연속적이어서 캐시 성능이 좋다는 장점으로 게임 프로그래밍에서 많이 사용됩니다. 배열의 크기를 미리 알 수 없는 경우 **동적 배열(dynamic array)** 또는 벡터(`std::vector`)를 사용하는 것이 좋습니다. 동적 배열은 고정 크기 배열의 장점을 유지하면서 런타임에 크기 조절이 가능합니다. 버퍼가 부족하면 더 큰 버퍼를 할당하고 기존 데이터를 복사한 후 원래 버퍼를 해제합니다. 버퍼의 크기는 일정한 규칙(예: 매번 일정량 추가, 2배씩 커짐)에 의해 커집니다. 동적 배열을 사용할 때는 주의를 기울여야 하며, 사용될 버퍼 크기를 아직 정하지 못한 개발 기간에 가장 유용할 수 있습니다.

*   **6.3.6 사전과 해시 테이블**
    **사전(`Dictionary`)**은 키-값 쌍의 테이블로, 키가 주어지면 값을 빠르게 찾아줍니다. 이진 검색 트리나 **해시 테이블**로 구현하는 것이 보통입니다.
    *   **해시 테이블**: 고정 크기 테이블에 값들을 저장하는데, 키를 **해시 함수**로 변환하여 해시 값을 얻고, 이 해시 값을 테이블 크기로 모듈로 연산하여 테이블에 대한 인덱스를 계산합니다. 충돌이 없다고 가정하면 키-값 쌍을 찾는 동작은 **O(1) 상수 시간**입니다.
    *   **6.3.6.1 충돌: 개방형 해시 테이블과 폐쇄형 해시 테이블**
        두 개 이상의 키가 해시 테이블의 같은 슬롯을 차지하는 **충돌(`Collision`)**이 발생할 수 있습니다.
        *   **개방형 해시 테이블(`Open Hash Table`)**: 충돌을 해결하기 위해 각 인덱스에 여러 키-값 쌍을 저장하는 연결 리스트 등을 가집니다. 구현하기 쉽고 저장할 수 있는 쌍의 수에 제약이 없지만, **새로운 키-값 쌍을 추가할 때 동적 메모리 할당이 발생**합니다.
        *   **폐쇄형 해시 테이블(`Closed Hash Table`)**: 충돌 시 빈 슬롯을 찾을 때까지 다른 슬롯을 **탐지(`probing`)**하는 과정을 반복합니다. 구현이 좀 더 까다롭고 저장할 수 있는 최대 키-값 쌍의 수에 제한이 있지만, **정해진 양의 메모리만 사용하며 동적 메모리 할당이 필요 없다는 가장 큰 장점**이 있어 게임 엔진에 적합합니다.
    *   **6.3.6.2 해시 값 계산**
        해시 값 계산은 키 값을 정수로 바꾼 후 이 정수와 테이블 크기를 모듈로 연산해 테이블에 대한 인덱스를 얻는 과정입니다. 해시 테이블의 효율성은 **해시 함수의 품질**에 달려 있습니다. '좋은' 해시 함수는 가능한 한 키들을 테이블 전체에 고르게 배분하여 충돌을 최소화하고, 속도가 빠르며, 입력값이 같으면 항상 같은 값을 리턴하는 **결정적(`deterministic`) 함수**여야 합니다. 가장 자주 해시될 키 타입은 문자열이므로 문자열 해시 함수를 잘 아는 것이 중요합니다. 너티 독은 CRC32 알고리듬을 문자열 해시에 사용했으며, 2년 넘게 개발하는 동안 충돌은 한 번도 일어나지 않았습니다.
    *   **6.3.6.3 폐쇄형 해시 테이블 구현**
        폐쇄형 해시 테이블은 키-값 쌍을 테이블 안에 직접 저장하므로, 필요한 메모리 양을 미리 정확히 알 수 있습니다. 충돌이 발생하면 탐지 과정을 거칩니다. 가장 단순한 탐지 방식은 **선형 탐지(`linear probing`)**로, 현재 슬롯이 비어 있지 않으면 `+1`, `+2` 등 순차적으로 다음 슬롯을 뒤지는 방식입니다. **이차 탐지(`quadratic probing`)**는 `+i^2` 방식으로 탐색하여 키-값 쌍이 뭉치는 현상을 방지합니다. 테이블 크기를 **소수(`prime number`)**로 하는 것이 탐지 충돌을 최소화하고 테이블을 고르게 배열하는 데 좋습니다.
    *   **6.3.6.4 로빈 후드 해시**
        최근 각광받고 있는 폐쇄형 해시의 탐지 방식입니다. 폐쇄형 해시 테이블이 거의 가득 찼을 때도 성능을 향상시키는 효과가 있습니다.

---

### 6.4 문자열

문자열은 게임 엔진 전반에 걸쳐 광범위하게 사용되지만, **런타임 문자열 연산은 근본적으로 느리다**는 문제가 있습니다. 문자열 비교는 `strcmp()` 같은 글자 배열 순회 함수를 사용해야 하고(`O(n)`), 문자열 복사는 `O(n)` 메모리 복사 작업이며, 동적 할당까지 관여하면 성능 비용이 더욱 커집니다.

*   **6.4.1 문자열의 문제점**
    C와 C++에서 문자열은 글자 배열로 구현되며 그 길이가 가변적이므로, 최대 길이를 코드에서 제한하거나 문자열 버퍼를 동적 할당해야 합니다. 또한, **현지화(`Localization`, L10n)** 문제는 소프트웨어를 다른 언어와 문화권에 맞게 변경하는 과정으로, 모든 언어의 글리프를 표시하고, 글자 정렬 방식(수직 정렬, 우측에서 좌측 읽기 등)을 지원하며, 번역된 문자열의 길이 변화를 처리할 수 있어야 합니다. 게임 엔진 내부적으로 리소스 파일 이름이나 객체 이름 등에 문자열이 사용되므로, 엔진이 이러한 내부 문자열을 어떻게 처리하는지에 따라 게임 전반의 성능이 영향을 받습니다.

*   **6.4.2 문자열 클래스**
    C++ 프로그래머는 `std::string`과 같은 문자열 클래스를 선호하지만, 편리함 뒤에 **복사 생성자나 동적 할당으로 인한 숨겨진 성능 비용**이 있을 수 있습니다. 문자열 객체를 함수에 전달할 때, 값(`value`)으로 넘기면 불필요한 문자열 복사가 일어날 수 있으므로, **가급적 `const` 참조(`reference`)로 넘기는 것**이 좋습니다. 개인적으로는 런타임 게임 코드에서는 문자열 클래스 사용을 선호하지 않으나, 시스템 경로를 저장할 때와 같이 특수한 경우 `Path` 클래스 등을 통해 일반적인 C 스타일 문자 배열의 기능을 확장하여 활용할 수 있습니다.

*   **6.4.3 고유 식별자**
    가상 게임 월드에 있는 물체나 게임을 구성하는 자원(메시, 머티리얼, 텍스처, 오디오 클립, 애니메이션 등)은 고유하게 구분될 필요가 있습니다. 문자열은 사람이 기억하기 쉽고 자연스럽지만, 게임에서는 고유 식별자들끼리 **비교하는 속도가 매우 중요**하므로 `strcmp()` 같은 함수를 직접 사용하는 것은 비효율적입니다.
    *   **6.4.3.1 해시 문자열 (String ID)**
        문자열의 **해시 값**을 사용하는 것이 효과적인 방법 중 하나입니다. 해시 함수를 사용하면 문자열을 거의 고유한 **정수(해시 값)**로 바꿀 수 있으며, 이 해시 코드는 정수와 똑같이 비교할 수 있어 **비교 연산이 굉장히 빠릅니다(`O(1)`)**. 원본 문자열은 디버깅을 위해 해시 테이블에 저장하여 필요할 때 가져올 수 있으며, 이를 **문자열 ID(`String ID`)**라고 부르기도 합니다. 언리얼 엔진은 이를 `FName` 클래스로 구현합니다. 너티 독은 CRC32 알고리듬을 문자열 해시에 사용했으며, 2년 넘게 개발하는 동안 충돌은 한 번도 일어나지 않았습니다.
    *   **6.4.3.2 몇 가지 구현 아이디어**
        대부분의 게임 엔진은 **런타임에 해시 값을 계산하지 않습니다**. 너티 독은 런타임 문자열 해시도 사용했지만, 소스 코드를 전처리하는 도구를 만들어 컴파일 시점에 문자열 리터럴을 적절한 해시 값(정수 상수)으로 바꾸는 방식도 사용했습니다. 문자열에서 해시 ID를 만드는 과정을 **인턴(`interning`)**한다고 부르기도 하는데, 이는 문자열의 해시 값을 구하는 동시에 룩업 테이블에 문자열을 추가하여 나중에 해시 코드로 원본 문자열을 찾을 수 있게 하는 것입니다. 인턴 과정은 시간이 오래 걸리므로, 한 번만 인턴하고 그 값을 저장하여 재사용하는 것이 좋습니다. 게임 출시 시에는 원래 문자열이 더 이상 필요 없을 가능성이 크므로, 문자열 테이블을 디버그 메모리 등 접근 불가능한 장소에 보관하여 메모리 사용량을 줄일 수 있습니다.

*   **6.4.4 현지화 (Localization, L10n)**
    게임을 현지화하는 일은 매우 큰 작업으로, 이상적으로는 개발 초기부터 계획을 세우고 지속적으로 관리해야 합니다.
    *   **6.4.4.1 유니코드 (Unicode)**
        전 세계 모든 언어의 문자를 표현하기 위한 표준 인코딩으로, 모든 글리프에 고유한 코드 포인트(16진수)를 부여합니다. 유니코드 코드포인트를 각 캐릭터로 나타내는 방식인 **인코딩(`encoding`)**을 선택하여 문자열을 저장합니다. **UTF-8**과 **UTF-16**이 주로 쓰이는 인코딩 방식입니다.
        *   **UTF-8**: 가변 길이 인코딩으로, 코드 포인트가 기본 8비트(1바이트) 단위지만 일부는 더 큰 공간을 차지합니다. **ANSI 인코딩과 하위 호환이 가능**하다는 큰 장점이 있습니다. 유니코드 코드 포인트의 첫 127글자가 ANSI 캐릭터 세트와 정확히 일치하기 때문입니다.
        *   **UTF-16**: 각 캐릭터가 1개 또는 2개의 16비트 값으로 표현되는 가변 길이 인코딩입니다. '와이드 문자(`Wide Character Set`)'라고도 불립니다. 모든 유니코드 코드 포인트를 17개의 평면으로 나누며, 주로 쓰이는 기본 다국어 평면의 문자는 단 하나의 16비트 값으로 표현되지만, 보충 다국어 평면의 문자는 2개의 연속된 16비트 값으로 표현됩니다.
        *   **UCS-2**: UTF-16의 하위 세트로 기본 다국어 평면만 사용하며, 각 글자가 정확히 16비트(2바이트)를 차지하는 **고정 길이 인코딩**입니다.
    *   **6.4.4.2 char vs wchar_t**
        C/C++ 표준 라이브러리는 문자열을 다루기 위해 `char`와 `wchar_t` 두 가지 데이터 타입을 정의합니다. `char` 타입은 구식 ANSI 문자열과 UTF-8 등의 다중 바이트 문자 세트를 처리하는 데 쓰입니다. `wchar_t` 타입은 '와이드' 문자를 처리하며, 하나의 정수로 유니코드 코드 포인트를 처리하도록 설계되었으나 그 크기는 컴파일러와 시스템에 따라 다를 수 있습니다. 진정한 이식 가능한 문자열 처리를 위해서는 직접 문자 데이터 타입을 정의하고 모든 유니코드 인코딩에 대응하는 라이브러리 함수들을 제공해야 합니다.
    *   **6.4.4.3 Windows 환경에서의 유니코드**
        Windows 환경에서 `wchar_t` 타입은 UTF-16 인코딩 유니코드 문자열을 나타내고, `char`는 ANSI 문자열과 구형 Windows 코드 페이지 인코딩에 쓰입니다. Windows API는 단일 바이트, 다중 바이트, 와이드 문자 세트 문자열용 함수를 지원합니다. 접미사나 접두사로 `W`, `wc`, `T` 등이 붙는 함수들은 와이드 문자(`UTF-16`)를 뜻하고, `mb`는 다중 바이트 인코딩을 뜻합니다. 이식성을 위해 `TCHAR` 매크로를 사용하여 문자 타입을 정의하고, `T()` 매크로를 사용하여 문자열 리터럴을 컴파일러 설정에 따라 변환할 수 있습니다.
    *   **6.4.4.4 콘솔에서의 유니코드**
        엑스박스 360 SDK에서는 거의 모든 문자열이 WCS(UTF-16) 문자열입니다. 반면 너티 독의 엔진들은 8비트 `char` 문자열을 광범위하게 사용하고, 외국어를 처리할 때 UTF-8 인코딩을 사용했습니다. 어떤 인코딩을 사용하든, 프로젝트 시작 시 결정하고 일관되게 사용하는 것이 중요합니다.
    *   **6.4.4.5 기타 현지화에서 고려해야 할 점**
        현지화는 음성 녹음 오디오, 번역될 텍스처, 문화적 상징, 게임 등급 시스템 등 기술 외적인 다양한 측면을 고려해야 합니다. 가장 중요한 부분은 **사람이 읽을 수 있는 문자열들의 중심 데이터베이스**와 이 문자열들을 게임 내에서 찾을 수 있게 하는 시스템입니다. 번역될 모든 문자열을 고유 ID와 함께 중앙 데이터베이스(예: MySQL, Excel, CSV, XML 등)로 관리하는 것이 일반적입니다. `getLocalizedString(id)`와 같은 함수를 통해 런타임에 현재 언어의 문자열을 가져올 수 있어야 합니다.
    *   **6.4.4.6 케이스 스터디: 너티 독의 현지화 도구**
        너티 독은 자체 개발한 현지화 데이터베이스를 사용했습니다. 백엔드는 MySQL 데이터베이스로, 너티 독 내부 개발자와 텍스트 및 오디오 번역을 담당하는 여러 외부 협력사들이 동시에 접근할 수 있게 구성되었습니다. 프론트엔드는 웹 인터페이스로, 데이터베이스와 통신하며 텍스트와 오디오 자원 검색 및 편집이 가능합니다. 각 문자열이나 대사 오디오 클립 및 자막 텍스트는 **해시 스트링으로 된 고유 식별자**를 가집니다. `getLocalizedString()`와 같은 함수를 통해 ID로 해당 언어의 문자열을 가져올 수 있으며, 웹 인터페이스를 통해 다양한 언어의 번역 결과를 시각적으로 확인할 수 있습니다.

---

### 6.5 게임 설정

게임 설정은 플레이어가 게임 내에서 조정하는 옵션(그래픽 품질, 사운드 볼륨, 컨트롤러 설정 등)과 개발 팀에서만 사용하는 옵션으로 나뉩니다. 설정은 전역 변수나 싱글턴 클래스의 멤버 함수로 간단하게 구현할 수 있으며, 설정된 값을 하드디스크나 메모리 카드 등 저장 장치에 **저장하고 불러오는 기능**이 필수적입니다.

*   **설정 저장 및 불러오기 방법**:
    *   **텍스트 설정 파일**: INI, JSON, XML 등. 가장 널리 쓰이며 읽기 쉬운 형식입니다. 오거 엔진도 INI 형식을 사용합니다.
    *   **압축 이진 파일**: 메모리 제한이 있는 구형 콘솔의 메모리 카드 저장에 주로 사용되었습니다. 저장 공간이 작았기 때문에 압축된 이진 파일이 효율적이었습니다.
    *   **운영체제 레지스트리**: 마이크로소프트 Windows의 레지스트리는 계층적 키-값 데이터베이스로, 프로그램 설정 저장에 사용됩니다.
    *   **커맨드 라인 옵션**: 엔진의 모든 또는 일부 설정을 커맨드 라인 인자로 지정할 수 있습니다.
    *   **환경 변수**: 개인용 컴퓨터에서 설정 옵션을 저장하는 데 사용될 수 있습니다.
    *   **온라인 유저 프로파일**: Xbox Live와 같은 온라인 게이밍 커뮤니티 시대에는 사용자마다 프로파일을 만들어 업적, 구매 기능, 게임 옵션 등 다양한 정보를 중앙 서버에 저장하고 인터넷 연결을 통해 언제든 접근할 수 있게 합니다.

*   **6.5.2 사용자별 정보**
    대부분의 게임 엔진은 전역 옵션과 **사용자별 옵션**을 구분하여 플레이어나 개발 팀원이 자신만의 설정 환경을 가질 수 있도록 지원합니다. 사용자별 설정 데이터는 일반적으로 메모리 카드 슬롯이나 OS의 사용자별 폴더(예: Windows의 `C:\Users\[사용자명]\AppData`)에 파일로 저장되거나, 레지스트리(`HKEY_CURRENT_USER` 하부 키)에 저장될 수 있습니다.

*   **6.5.3 실제 게임 엔진들의 설정 관리**
    *   **6.5.3.1 예: 퀘이크의 CVAR**
        퀘이크 계열 엔진은 **콘솔 변수(`console variables`, CVAR)** 시스템을 통해 게임 설정을 관리합니다. 각 CVAR은 `cvar_t` 구조체로 구현된 인스턴스로, 변수 이름, 값(문자열 또는 부동소수), 플래그 등을 가집니다. `Cvar_Get()` 함수를 사용해 CVAR을 가져오고, `Cvar_Set()` 함수로 값을 수정할 수 있습니다. 비트 플래그 중 하나인 `CVAR_ARCHIVE`는 해당 CVAR의 값이 설정 파일(`config.cfg`)에 저장될지 여부를 지정하여 게임 재실행 시 값을 보존할 수 있게 합니다.
    *   **6.5.3.2 예: 오거 (Ogre)**
        오거 렌더링 엔진은 Windows INI 형식의 텍스트 파일 여러 개를 사용하여 설정을 저장합니다. 기본적으로 `plugins.cfg`, `resources.cfg`, `ogre.cfg` 세 파일에 저장됩니다. `plugins.cfg`는 사용할 플러그인 정보를, `resources.cfg`는 게임 자원 검색 위치를, `ogre.cfg`는 렌더러, 비디오 모드, 스크린 해상도 등 다양한 옵션을 저장합니다. 기본적으로 사용자별 설정을 저장하는 방법은 없지만, 소스 코드가 공개되어 있어 `Ogre::ConfigFile` 클래스를 활용해 쉽게 변경할 수 있습니다.
    *   **6.5.3.3 예: 언차티드와 라스트 오브 어스 시리즈**
        너티 독의 언차티드 엔진은 여러 가지 설정 기법을 사용합니다.
        *   **인게임 메뉴 설정**: 강력한 인게임 메뉴 시스템을 통해 개발자가 설정 옵션을 제어하고 명령을 실행할 수 있습니다. 설정 옵션은 **전역 변수**로 구현되며, 메뉴 아이템이 직접 그 값을 조정합니다. 이러한 설정은 INI 스타일 파일에 저장되어 게임 재실행 시에도 유지됩니다. 메뉴 아이템마다 저장할지 말지를 정할 수 있는 기능이 있어, 저장 안 된 옵션들은 프로그래머가 지정한 기본값으로 설정됩니다.
        *   **스킴 데이터 정의**: 언차티드 엔진 및 게임 데이터 대부분은 **리스프(`Lisp`)와 유사한 스킴(`Scheme`)** 언어로 작성됩니다. 스킴으로 정의한 자료 구조는 **전용 데이터 컴파일러를 통해 엔진에서 불러올 수 있는 이진 파일로 변환**됩니다. 이 데이터 컴파일러는 동시에 스킴으로 정의한 모든 데이터 타입에 대한 **C++ `struct` 선언을 담은 헤더 파일도 생성**하여 엔진이 이진 파일을 적절하게 해석하는 데 사용됩니다. 개발자는 스킴 데이터를 고치고 그 결과를 즉시 확인할 수 있는데(데이터 멤버 추가/제거 시에는 엔진 재컴파일 필요), 이는 정교한 애니메이션 트리나 물리 엔진 매개변수 등 복잡한 게임 데이터를 유연하게 정의하는 데 실제로 사용될 수 있습니다.

---