# 4장 병렬성과 병행 프로그래밍

## 4.1 병행성과 병렬성에 대한 정의

### 4.1.1 병행성 (Concurrency)

- 하나의 문제를 해결하기 위해 여러 개의 제어 흐름을 활용.
- 제어 흐름:
  - 한 프로세스 내 여러 스레드(thread) 사용
  - 여러 컴퓨터에 분산된 프로세스
  - 파이버(fiber)나 코루틴(coroutine) 사용
- 병행 프로그래밍과 순차적 프로그래밍의 핵심 차이: **공유 데이터에 대한 접근**
- **독립적 데이터**를 처리하는 것은 병행성이 아님.

### 병행성의 문제
- 공유 데이터에 대한 일관성, 정확성 확보가 중요
- **데이터 경쟁 상태(race condition)** 발생 위험
- 병행성의 핵심은 데이터 경쟁을 **찾고 제거**하는 것

---

### 4.1.2 병렬성 (Parallelism)

- **둘 이상의 하드웨어가 동시에 작동**하는 상태
- 예: 하나의 병렬 컴퓨터 → 여러 작업 동시 수행
- 반대: 직렬(serial) 컴퓨터 → 한 번에 하나의 작업만

#### 과거:
- 1989년 이전 대부분의 소비자용 컴퓨터는 직렬 구조
  - Apple II, 6502 CPU, Intel 8086/80286/80386 등

#### 현재:
- 멀티코어 CPU (Intel Core i7, AMD Ryzen 등)
- 다양한 병렬 컴퓨팅 형태로 확장 가능
  - 예: CPU 내부 ALU 병렬 구성, 컴퓨터 클러스터(cluster) 등

---

#### 4.1.2.1 묵시적 병렬성과 명시적 병렬성

* 묵시적 병렬성 (Implicit Parallelism)

  - 하나의 명령어 스트림을 효율적으로 처리하기 위해 CPU 내부 구성 요소 사용
  - 명령어 수준 병렬성(ILP: Instruction Level Parallelism)
  - 예시:
    - 파이프라인(pipeline)
    - 슈퍼스칼라 아키텍처(superscalar architecture)
    - VLIW 아키텍처

* 명시적 병렬성 (Explicit Parallelism)
  - 둘 이상의 명령어 스트림을 처리
  - CPU/시스템에 중복된 하드웨어 사용
  - **병행 소프트웨어**를 효율적으로 처리하기 위한 하드웨어 설계

    - 예시:
      - 하이퍼스레드 CPU
      - 멀티코어 CPU
      - 멀티프로세서 컴퓨터
      - 컴퓨터 클러스터(cluster)
      - 그리드 컴퓨팅(grid computing)
      - 클라우드 컴퓨팅(cloud computing)

---

### 4.1.3 작업 병렬성과 데이터 병렬성

- 병렬성을 이해하는 또 다른 방법은 **작업의 종류**에 따라 나누는 것.
  
#### ● 작업 병렬성 (Task Parallelism)
- 이질적인 명령어들이 병렬적으로 여러 실행됨 → 작업 병렬성
- 예: 한 코어에서 애니메이션 계산, 다른 코어에서는 충돌 체크 수행

#### ● 데이터 병렬성 (Data Parallelism)
- 하나의 동일한 명령어가 여러 데이터를 병렬적으로 수행하는 것
- 예: 4개의 코어가 각각 250개의 스키닝 행렬 계산

> 대부분의 병렬 프로그램은 이 두 가지 병렬성을 혼합하여 사용

---

### 4.1.4 플린 분류 (Flynn's Taxonomy)

- 마이클 J. 플린이 제안한 병렬성의 분류 방식 (1996)
- 병렬성을 제어 흐름(명령어 스트림)과 데이터 스트림 수의 조합으로 4가지로 구분

#### ● SISD (Single Instruction, Single Data)
- 하나의 명령어 스트림이 하나의 데이터 스트림 처리
- 가장 기본적인 구조

#### ● MIMD (Multiple Instruction, Multiple Data)
- 여러 명령어 스트림이 여러 데이터 스트림 처리
- 대표적인 병렬 구조

#### ● SIMD (Single Instruction, Multiple Data)
- 하나의 명령어 스트림이 여러 데이터 스트림을 동시에 처리

#### ● MISD (Multiple Instruction, Single Data)
- 여러 명령어 스트림이 하나의 데이터 스트림을 처리
- 거의 사용되지 않으며, 예외적인 상황에만 사용됨 (예: 오류 복구, 핫 스페어 등)

---

### 4.1.4.1 단일 데이터와 다중 데이터

- "데이터 스트림"은 단순한 숫자 배열이 아님 → 연산자 중심의 설명 필요
- 대부분 연산자는 2개의 입력을 받아 1개의 결과 출력

#### ● SISD
- 하나의 ALU가 곱 연산 후 나누기 연산 수행  
  `mul a, b` → `div c, d`

#### ● MIMD
- 2개의 ALU가 서로 독립적인 명령어 스트림을 병렬 수행  
  `ALU0: mul a, b`, `ALU1: sub g, h`

#### ● 시간 분할 MIMD
- 하나의 ALU가 시분할 방식으로 2개의 명령어 스트림을 처리

#### ● SIMD
- 벡터 처리 유닛(VPU)을 사용해 한 쌍의 4원소 벡터를 입력받아 연산

#### ● MISD
- 동일한 명령어 스트림을 두 ALU가 나눠 수행하여 **이론적으로 동일한 결과**를 출력
- 핫 스페어(hot spare)로 사용되기도 함

---

### 4.1.4.2 GPU 병렬성: SIMT

- SIMT (Single Instruction Multiple Thread): GPU 설계에서 SIMD와 MIMD의 혼합 구조
- **멀티스레딩** 기법을 사용해 명령어 스트림을 시간 분할하여 병렬 처리
- 다양한 제조사들이 채택하는 디자인
- ‘매니코어(manycore)’라는 표현도 사용됨

---

### 4.1.5 병행성과 병렬성의 직교적 성질

- 병렬 하드웨어 없이도 병행 소프트웨어는 가능
- 병행성과 병렬성은 **서로 독립적 개념**이지만, 함께 쓰이면 성능 향상 가능

#### 예:
- 단일 스레드 CPU에서도 병행 소프트웨어 실행 가능 (멀티태스킹 등)
- 단일 명령어 수준 병렬성도 성능 향상 목적

---

### 4.1.6 4장의 로드맵

- 4.2절: 묵시적 병렬성에 대해 설명
- 4.3절: 명시적 병렬성의 형태 확인
- 이후 다양한 병렬 프로그래밍 기법을 살펴봄
- 마지막으로 SIMD 벡터 프로세싱과 GPU 병렬 프로그래밍(GPGPU) 적용 사례 분석

---

p.237 차례