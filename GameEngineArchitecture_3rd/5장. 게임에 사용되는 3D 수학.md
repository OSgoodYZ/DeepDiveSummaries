
# 5장 게임에 사용되는 3D 수학

## 5.2 점과 벡터
게임 엔진은 가상 세계 안의 3D 물체들의 위치, 방향, 스케일 등을 관리하고 애니메이션하며, 화면에 그릴 수 있도록 좌표계를 변환하는 일을 합니다. 3D 물체는 대부분 삼각형으로 만들어지고 각 삼각형의 꼭지점은 '점'으로 표현됩니다. '벡터'는 점과 매우 유사한 개념입니다.

### 5.2.1 점과 직교 좌표계
*   **점(Point)**: n차원 공간(주로 2D 또는 3D)에서의 특정 '위치'를 나타냅니다.
*   **직교 좌표계(Cartesian coordinate system)**: 게임 프로그래밍에서 가장 흔히 사용하는 좌표계로, 2개나 3개의 서로 수직인 축을 이용해 3D 공간에서 위치를 표시합니다.
*   **기타 좌표계**: 원통 좌표계(수직 높이, 반지름, 수평 각도)나 구면 좌표계(수직 각도, 수평 각도, 반지름)도 특정 문제 해결에 유용할 수 있습니다. 당면한 문제를 가장 잘 나타낼 수 있는 좌표계를 선택하는 것이 중요합니다.

### **5.2.2 왼손 좌표계와 오른손 좌표계**
*   **정의**: 3차원 직교 좌표계에서 세 축을 표현하는 두 가지 방식입니다. 오른손으로 축을 감싸는 상상으로 엄지손가락이 Z축의 양의 방향이 되게 할 때, 손가락들이 X축에서 Y축 방향을 가리키면 오른손 좌표계이고, 왼손을 사용하면 왼손 좌표계가 됩니다.
*   **차이점**: 두 좌표계의 유일한 차이점은 한 축이 가리키는 방향입니다. 예를 들어, X축이 아래를, Y축이 오른쪽을 가리킬 때, Z축이 책 밖으로 나오는 방향이면 오른손 좌표계, 책 안쪽으로 들어가는 방향이면 왼손 좌표계입니다.
*   **변환**: 한 좌표계에서 다른 좌표계로 바꾸는 것은 세 축 중 어느 한 축의 부호만 바꾸면 됩니다.
*   **수학적 원리**: 좌표계 방식은 계산 규칙에 영향을 주지 않고, 단지 3D 공간에 숫자가 어떻게 위치하는가(시각적 표현)에 대한 생각일 뿐입니다. 다만, 벡터의 외적 연산은 좌표계에 따라 결과 방향이 달라질 수 있습니다.
*   **유사 벡터(Pseudovector)**: 외적의 결과는 일반적인 벡터가 아니라 '유사 벡터'라는 특수한 수학 개념으로, 좌표계를 반전시킬 때(왼손/오른손 좌표계 변환 시) 특수한 성질이 드러납니다.
*   **일관성**: 어떤 좌표계를 사용하든 정해서 일관되게 사용하는 것이 중요합니다. 3D 그래픽 프로그래머들은 주로 왼손 좌표계를 사용하며, Y축은 위쪽, X축은 오른쪽, Z축은 멀어지는 방향(카메라가 바라보는 방향)을 나타냅니다.

### **5.2.3 벡터(Vectors)**
*   **정의**: n차원 공간에서 '크기'와 '방향'을 나타내는 값으로, 방향이 있는 선으로 그릴 수 있으며 한 점(꼬리)에서 다른 한 점(머리)으로 이어집니다. 방향이 없고 크기만 있는 '스칼라 값'과 반대되는 개념입니다.
*   **점과 벡터의 구분**: 엄밀히 말하면 벡터는 특정 점에 대한 '차이(오프셋)' 값을 의미합니다. 벡터는 공간 어디든 위치할 수 있지만 크기와 방향이 같으면 같은 벡터입니다. 점은 절대적인 속성, 벡터는 상대적인 속성이라고 말하기도 합니다.
*   **위치 벡터(Position vector)**: 벡터가 점을 나타내는 데 쓰일 때는 꼬리가 좌표계의 원점에 와야 하며, 이를 위치 벡터 또는 반지름 벡터(radius vector)라고 부릅니다.
*   **동차 좌표(Homogeneous coordinates)**: 4x4 행렬 연산을 위해 점과 방향 벡터를 동차 좌표로 바꿀 때 다르게 취급해야 합니다. 점은 w 값을 1로, 방향 벡터는 w 값을 0으로 하여 평행 이동이 점에는 적용되고 방향 벡터에는 무시되도록 합니다.
*   **기저 벡터(Basis vectors)**: 서로 수직이면서 직교 좌표계의 각 축 방향인 세 단위 벡터(크기가 1인 벡터)를 정의하는데, X, Y, Z축 방향 단위 벡터를 각각 i, j, k로 나타내며 이들을 기저 벡터라고 부릅니다. 어떤 점이나 벡터라도 세 기저 벡터에 스칼라 값을 곱한 값의 합으로 표현할 수 있습니다.

### **5.2.4 벡터 연산**
스칼라 값에 사용하는 대부분의 수리 연산을 벡터에도 쓸 수 있으며, 벡터에만 쓸 수 있는 연산도 있습니다.

*   **스칼라 값과의 곱**: 벡터의 각 성분에 스칼라 값을 곱하여 벡터의 크기를 변화시키지만 방향은 변하지 않습니다. -1을 곱하면 방향만 뒤집힙니다. 축마다 서로 다른 스케일 값을 곱하는 '아다마르 곱셈(Hadamard product)'도 있습니다.
*   **덧셈과 뺄셈**: 각 성분끼리 더하거나 빼서 새로운 벡터를 만듭니다. 벡터의 덧셈은 한 벡터의 머리에 다른 벡터의 꼬리를 갖다 놓은 모양을 상상하면 됩니다. 방향 벡터끼리는 더하고 빼는 데 문제가 없지만, 점끼리 더하거나 빼는 것은 성립하지 않습니다.
*   **크기(Magnitude)**: 2D나 3D 공간 안에서 벡터의 길이를 나타내는 스칼라 값입니다. 피타고라스 정리를 이용해 계산합니다. 제곱근 연산은 시간이 오래 걸리므로, 성능 최적화를 위해 크기의 제곱을 사용하는 것이 좋습니다.
*   **정규화(Normalization)와 단위 벡터(Unit vector)**: 단위 벡터는 크기가 1인 벡터를 말합니다. 어떤 벡터든 그 크기의 역수를 곱하면 단위 벡터로 정규화할 수 있습니다. 정규화된 벡터는 크기가 1인 모든 벡터를 뜻합니다.
*   **법선 벡터(Normal vector)**: 어떤 평면에 수직인 벡터를 법선 벡터라고 합니다. 3D 그래픽에서 면의 방향이나 빛과의 상대적인 각도를 계산하는 데 자주 사용됩니다. 법선 벡터는 보통 크기가 1이지만 반드시 그래야 할 필요는 없습니다.
*   **내적(Dot Product)**: 두 벡터의 성분끼리 곱한 후 더하여 '스칼라 값'을 결과로 얻는 연산입니다. 이는 두 벡터의 크기를 곱한 값에 두 벡터가 이루는 각도의 코사인 값을 곱한 것과도 같습니다. 내적은 교환 법칙과 분배 법칙이 성립합니다.
    *   **투영**: 단위 벡터와의 내적은 다른 벡터를 그 단위 벡터 방향의 선에 투영한 크기입니다.
    *   **크기 구하기**: 벡터를 자기 자신과 내적하면 그 크기를 제곱한 값이 나옵니다.
    *   **활용**: 두 벡터가 평행한지, 수직인지, 같은 방향인지, 다른 방향인지를 알 수 있습니다. 게임에서는 적이 플레이어 앞에 있는지 뒤에 있는지 판단하거나, 평면과 점 사이의 거리를 구하는 데 사용됩니다.
*   **외적(Cross Product)**: 두 벡터에 '수직인 다른 벡터'를 결과로 얻는 연산으로, 3차원에서만 의미가 있습니다. 외적 벡터의 크기는 두 벡터가 이루는 평행사변형의 넓이와 같습니다.
    *   **방향**: 오른손 좌표계에서는 오른손 법칙을, 왼손 좌표계에서는 왼손 법칙을 따릅니다. 이로 인해 외적 벡터의 방향은 어떤 좌표계를 쓰느냐에 따라 달라질 수 있습니다.
    *   **성질**: 외적은 교환 법칙이 성립하지 않습니다(순서가 중요합니다). 덧셈에 대한 분배 법칙과 스칼라 값과의 곱셈 성질은 성립합니다.
    *   **활용**: 게임에서 가장 흔하게는 두 벡터에 수직인 법선 벡터를 찾거나 물체의 회전 운동력(토크)을 계산하는 데 사용됩니다. 삼각형 표면이나 평면의 단위 법선 벡터를 구하는 데도 사용됩니다.
*   **유사 벡터와 외 대수**: 외적의 결과는 '유사 벡터(Pseudovector)'라는 특수한 개념입니다. 벡터와 유사 벡터의 차이는 좌표계를 반전시킬 때(왼손/오른손 좌표계 변환 시) 드러납니다. 회전 속도와 자기장은 유사 벡터로 표현되며, 삼각형의 표면 법선(외적을 통해 구함) 또한 유사 벡터입니다. 수학자들은 벡터와 유사 벡터를 함께 사용할 수 있도록 '외대수(Exterior algebra)' 또는 '그라스만 대수(Grassmann algebra)' 개념을 고안했으며, 이를 통해 평행사변형의 면적이나 평행육면체의 부피 계산을 할 수 있습니다.

### **5.2.5 점과 벡터의 선형 보간 (Linear Interpolation, LERP)**
*   **정의**: 두 개의 알려진 지점(점 또는 벡터) 사이의 중간 값을 계산하는 간단한 수리 연산입니다. `L = LERP(A, B, f) = (1 - f)A + fB` 로 정의되며, `f`는 양 끝점을 포함하는 0과 1 사이의 값입니다.
*   **의미**: LERP 결과는 `A`와 `B`를 잇는 선 위에 존재하며, `f` 비율만큼 `A`에서 `B`로 이동한 점입니다. 이는 두 점의 '가중 평균(weighted average)'과 같으며, 각 점은 `(1-f)`와 `f`만큼의 가중치를 가집니다. 두 가중치의 합은 항상 1입니다.
*   **활용**: 게임에서는 두 점(벡터) 사이의 중간 지점을 알아야 할 때, 예를 들어 물체가 두 지점 사이를 이동하는 애니메이션을 구현할 때 유용하게 사용됩니다.

주어진 자료와 대화 기록을 바탕으로 5.3절 '행렬'부터 5.3.5절 '전치 행렬'까지 요약하여 정리해드리겠습니다.

## 5.3 행렬

행렬은 m × n 스칼라 값들을 사각형 형태로 나열한 것입니다. 게임에서는 평행 이동, 회전 변환, 스케일과 같은 선형 변환을 표현하는 데 매우 편리하게 사용됩니다.

행렬을 표현할 때는 스칼라 값들의 집합을 대괄호로 묶으며, `M_rc` 형태로 표기할 때 `r`은 행, `c`는 열 번호를 나타냅니다.

### 5.3.1 행렬의 정의와 기본 연산
오늘날 대부분의 3D 게임은 가상 세계 안의 3차원 물체들로 이루어지며, 게임 엔진은 이러한 물체들의 위치, 방향, 스케일 등을 관리하고 애니메이션시키며, 스크린에 그리는 역할을 합니다.

*   **3x3 행렬의 특수 직교 행렬 (Special Orthogonal Matrix)**
    *   3x3 행렬에서 각 행과 열을 구성하는 벡터가 단위 벡터(크기가 1인 벡터)인 경우를 의미합니다.
    *   이러한 행렬은 순수한 회전 변환만을 나타냅니다.
*   **4x4 변환 행렬 (Transformation Matrix)**
    *   평행 이동, 회전 변환, 스케일 등 임의의 3D 변환을 표현할 수 있는 행렬입니다.
    *   게임 엔진에서 가장 유용하게 사용되는 행렬이며, 점과 벡터를 이 변환 행렬과 곱하여 변환합니다.
    *   **아핀 행렬 (Affine Matrix)**
        *   4x4 변환 행렬의 한 형태로, 변환 전후에 선의 평행이나 상대적인 길이는 유지되지만, 절대적인 길이 또는 각도는 변할 수 있습니다.
        *   회전, 평행 이동, 스케일, 층밀림(shear) 등의 연산이 조합된 것입니다.
*   **행렬 곱셈 (Matrix Multiplication)**
    *   두 행렬 A와 B의 곱은 `P = AB`로 나타내며, 두 가지 변환을 합한 또 다른 변환 행렬이 됩니다. 예를 들어, A가 스케일 행렬이고 B가 회전 변환 행렬인 경우, P는 스케일과 회전 변환을 모두 나타냅니다.
    *   이 성질은 게임 프로그래밍에서 특히 유용합니다. 여러 변환을 미리 계산하여 하나의 행렬에 저장한 후 벡터에 곱하면 각 변환을 개별적으로 곱하는 것보다 훨씬 효율적입니다.
    *   **행렬 곱셈의 조건**: 첫 번째 행렬의 열 개수와 두 번째 행렬의 행 개수가 같아야 합니다.
    *   **결과 행렬의 성분**: `P` 행렬의 한 성분은 첫 번째 행렬의 해당 행과 두 번째 행렬의 해당 열을 벡터 내적한 결과입니다.
    *   **비교환성**: 행렬 곱셈은 교환 법칙이 성립하지 않습니다 (`AB ≠ BA`). 즉, 곱하는 순서에 따라 결과가 달라집니다.
    *   **연쇄 변환 (Concatenation)**: 여러 개의 변환 행렬을 곱한 결과 행렬을 일컫는데, 곱한 순서대로 각 변환이 결합된 행렬이기 때문입니다.

### 5.3.2 점과 벡터를 행렬로 표현

점이나 벡터는 하나의 행(1 x n) 또는 하나의 열(n x 1)을 가진 행렬로 나타낼 수 있습니다 (n은 점과 벡터의 차원이며 보통 2나 3입니다).
예를 들어, 벡터 `v = (3, 4, -1)`은 행렬로 `` 또는 `^T`로 나타낼 수 있습니다. 여기서 위첨자 `T`는 행렬의 전치를 의미합니다.

*   **행 벡터와 열 벡터의 선택**
    *   어떤 형식(행 벡터 또는 열 벡터)을 사용할지는 선택하기 나름이지만, 행렬 곱셈의 표기 순서에 영향을 미칩니다.
    *   행렬 곱셈이 성립하려면 앞 행렬의 열과 뒤 행렬의 행의 수가 같아야 하기 때문에, 다음과 같은 규칙이 적용됩니다:
        *   **행 벡터 사용 시**: `1 x n` 행 벡터를 `n x n` 행렬에 곱하려면, 벡터가 행렬의 왼쪽에 와야 합니다 (`v' = vM`).
        *   **열 벡터 사용 시**: `n x 1` 열 벡터를 `n x n` 행렬에 곱하려면, 벡터가 행렬의 오른쪽에 와야 합니다 (`v' = Mv`).
    *   **다중 변환 적용 순서**
        *   `A, B, C`가 순서대로 적용되는 변환 행렬이라고 할 때:
            *   행 벡터 (`v`)인 경우: 변환 순서를 왼쪽에서 오른쪽으로 씁니다 (`v' = (((vA)B)C)`).
            *   열 벡터 (`v`)인 경우: 변환 순서를 오른쪽에서 왼쪽으로 먼저 적용합니다 (`v' = (C^T(B^T(A^T v)))`).
        *   쉽게 기억하려면 항상 벡터에 가까운 변환부터 적용된다고 생각하면 됩니다.
    *   **일관성 유지**: 사용 중인 게임 엔진이나 서적, 논문, 웹 페이지 등에서 어떤 형식을 따르는지 면밀히 점검하는 것이 중요합니다. 벡터가 왼쪽에 있으면 행 벡터, 오른쪽에 있으면 열 벡터를 사용하는 것입니다.

### 5.3.3 단위 행렬 (Identity Matrix)

단위 행렬은 어떤 행렬에 곱해도 결과가 변하지 않는 행렬입니다. 보통 `I`로 표기합니다.
단위 행렬은 행과 열의 수가 같으며, 대각선의 성분만 1이고 나머지는 전부 0입니다.
`AI = IA = A`의 성질을 가집니다.

### 5.3.4 역행렬 (Inverse Matrix)

역행렬은 어떤 행렬의 연산을 완전히 되돌리는 행렬을 말하며, `A^-1`로 표기합니다.
예를 들어, `A`가 z축 방향으로 37도 회전 변환하는 행렬이라면 `A^-1`는 z축 방향으로 -37도 회전하는 행렬이 됩니다. 마찬가지로 `A`가 크기를 2배 스케일하는 행렬인 경우, `A^-1`는 크기를 반으로 스케일하는 행렬입니다.
행렬과 그 역행렬을 곱하면 언제나 단위 행렬이 됩니다 (`AA^-1 = A^-1A = I`).
모든 행렬에 역행렬이 존재하는 것은 아니지만, 아핀 행렬(회전 변환, 평행 이동, 스케일, 층밀림 변환으로만 이루어진 행렬)은 역행렬이 존재합니다.
가우스 소거법이나 LU 분해법 등을 이용하면 역행렬이 존재하는 경우 역행렬을 찾을 수 있습니다.
여러 행렬을 곱한 것의 역행렬은 각 행렬의 역행렬을 구한 다음 반대 순서로 곱한 것과 같습니다: `(ABC)^-1 = C^-1 B^-1 A^-1`.

### 5.3.5 전치 행렬 (Transpose Matrix)

행렬 `M`의 전치 행렬은 `M^T`로 표기합니다. 전치 행렬은 원래 행렬을 대각선 기준으로 뒤집어 놓은 것으로, 원래 행렬의 행이 전치 행렬의 열이 되고 열은 행이 됩니다.
전치 행렬은 여러모로 유용하게 사용됩니다. 예를 들어, 직교 행렬(순수한 회전 변환)의 역행렬은 전치 행렬과 같습니다. 보통 역행렬을 구하는 것이 전치 행렬을 구하는 것보다 훨씬 어렵기 때문에 이는 특히 유용한 성질입니다.
또한, 수학 라이브러리 간에 열 벡터를 사용하는지 행 벡터를 사용하는지에 따라 데이터를 옮길 때 전치 행렬로 바꿔야 하는 경우가 있습니다.
역행렬과 마찬가지로, 행렬 곱에 대한 전치 행렬은 각 행렬의 전치 행렬들을 역순으로 곱한 것과 같습니다: `(ABC)^T = C^T B^T A^T`. 이 성질은 점과 벡터에 변환 행렬을 적용할 때 유용하게 사용됩니다.

### 5.3.6 동차 좌표(Homogeneous Coordinates)  
3x3 행렬로는 평행이동을 표현 할 수 없다. 따라서 4x4 행렬을 활용하고 3차원 점이나 벡터를 이런 식으로 4차원으로 확장한 것을 동차 좌표(Homogeneous Coordinates) 라고 칭한다.


### 5.3.7 기본 단위 변환 행렬

### 5.3.8 4 × 3 행 렬
게임에서는 가장 오른쪽 행을 생략하기도 한다.

### 5.3.9 좌표 공간
게임에서 3D 물체들의 위치와 방향을 정의하는 기준이 되는 공간들을 '좌표 공간'이라고 해요. 이는 물체가 어디에 있고 어떤 자세를 하고 있는지를 나타내기 위해 사용되는 개념입니다.

주로 게임에서는 세 가지 주요 좌표 공간이 사용됩니다다:
1.  **모델 공간 (Model Space):** 물체 자신만의 공간으로, 3D 모델이 처음 만들어질 때 사용되는 기준점이에요.
2.  **월드 공간 (World Space):** 게임 세계 전체의 공통된 공간으로, 모든 물체가 함께 존재하고 상호작용하는 대규모 가상 세계의 기준점입니다.
3.  **뷰 공간 (View Space):** 카메라에 고정된 공간으로, 카메라가 게임 세계를 어떻게 보고 있는지를 나타내는 기준점이에요.


### 5.3.10 기저 변환 (Basis Transformation)

'기저 변환'은 게임에서 물체의 위치, 방향, 크기 등을 다른 기준(좌표계)으로 바꾸는 과정입니다.

*   **좌표 공간의 관계**:
    *   모든 좌표 공간은 다른 공간에 대해 상대적이에요.
    *   이 공간들은 부모-자식 관계처럼 계층 구조를 이룹니다.
    *   '월드 공간'이 가장 위에 있는 기준점(부모 없음)이고, 다른 모든 공간은 월드 공간에 연결된 자식입니다.

*   **변환 행렬 만들기**:
    *   자식 공간의 물체를 부모 공간으로 옮기는 데 '변환 행렬'을 사용해요.
    *   이 행렬은 자식 공간의 축 방향(회전)과 자식 공간의 위치(평행 이동) 정보를 담고 있습니다.
    *   크기를 조절하려면 자식 공간 축의 '길이'를 조절하면 됩니다.

*   **행렬에서 정보 얻기**:
    *   반대로, 이미 만들어진 변환 행렬에서 물체의 방향이나 위치 같은 중요한 정보(기저 벡터)를 쉽게 뽑아낼 수 있습니다. 예를 들어, 자동차가 어느 방향을 보고 있는지 모델-월드 행렬에서 바로 알 수 있어요.

*   **변환의 일관성**:
    *   변환 행렬은 점이나 방향 같은 '벡터'를 변환하는 데 쓰입니다.
    *   혼란을 피하기 위해, 이 책에서는 벡터를 '행 벡터'로 사용하고 행렬 계산은 왼쪽에서 오른쪽으로 진행하는 방식을 일관되게 권장합니다.

### 5.3.11 법선 벡터 변환 (Normal Vector Transformation)

법선 벡터는 특정 평면이나 표면에 **항상 수직**인 벡터입니다.

*   **특징**:
    *   대부분 크기가 1인 '단위 벡터'이지만, 반드시 1이어야 하는 것은 아니에요.
    *   3D 그래픽에서 평면을 정의하거나, 면에 비치는 빛의 각도를 계산하는 데 사용됩니다.
*   **변환의 특수성**:
    *   일반 벡터와 달리, 법선 벡터를 변환할 때는 벡터의 '길이'와 '수직 조건'을 보존해야 합니다.
    *   이 때문에 평범한 변환 행렬이 아닌, **'역전치 행렬'을 곱해야** 올바르게 변환됩니다.
    *   이는 법선 벡터가 일반적인 '벡터'가 아니라 '유사 벡터'라는 특수한 수학적 개념이기 때문입니다.
*   **예외**: 만약 변환 행렬이 '균등한 스케일'만 포함하고 '층밀림(shear) 변환'이 없다면, 역전치 행렬 대신 일반 행렬을 사용해도 법선 벡터가 올바르게 동작합니다.

### 5.3.12 행렬을 메모리에 저장하는 방식 (Storing Matrices in Memory)

게임 엔진에서 행렬은 주로 C/C++의 2차원 배열 형태로 메모리에 저장됩니다.

*   **두 가지 저장 방식**:
    1.  **행 우선 (Row-major)**: 각 행(row)이 하나의 벡터(예: 기저 벡터 `i`, `j`, `k` 및 평행 이동 `t`)를 순서대로 저장하는 방식입니다.
        *   이 책에서 사용하는 '행 벡터' 규칙에 잘 맞습니다.
    2.  **열 우선 (Column-major)**: 각 열(column)이 하나의 벡터를 저장하는 방식입니다.
        *   SIMD(Single Instruction Multiple Data) 연산처럼 특정 마이크로프로세서에서 행렬-벡터 곱셈을 빠르게 할 때 유용할 수 있습니다.
*   **확인 방법**:
    *   대부분의 3D 수학 라이브러리는 행렬을 만드는 함수(예: 평행 이동 행렬 생성)를 제공하는데, 이 함수의 코드를 확인하거나, 특정 평행 이동 값을 주고 반환된 행렬을 디버거로 확인해보면 어떤 방식으로 저장되는지 알 수 있습니다.
    *   예를 들어, `(4, 3, 2)`로 평행 이동된 행렬의 마지막 행이 `[4.0, 3.0, 2.0, 1.0]`이라면 행 우선 방식입니다.
    
    
---

## 5.4 사원수 (Quaternions)

사원수는 3D 공간에서 **회전 변환을 표현**하는 데 사용되는 수학적 개념입니다. 행렬이 아닌 사원수를 사용하는 데는 몇 가지 이유가 있습니다.

*   **구조**: 1개의 실수부와 3개의 허수부로 구성되며, 일반적으로 `[qx qy qz qw]` 형태로 표현됩니다.
    *   `[qx qy qz]`는 회전축에 회전 반각의 사인 값을 곱한 벡터 부분입니다.
    *   `qw`는 회전 반각에 대한 코사인 값인 스칼라 부분입니다.
    *   **단위 길이 사원수**: 크기가 1인 사원수(정규화된 사원수)는 3D 회전 변환을 나타냅니다.
*   **사원수 연산**:
    *   **곱셈**: 두 사원수 `p`와 `q`를 곱하면 두 회전(`q`를 먼저 수행 후 `p` 수행)을 합친 결과가 됩니다. `pq`로 정의됩니다.
    *   **역**: 사원수 `q`의 역 `q⁻¹`은 원래 값과 곱했을 때 스칼라 값 1이 되는 사원수를 의미합니다. 단위 길이 사원수의 경우, 역은 켤레(`q*`)와 같습니다 (`q⁻¹ = q*`).
    *   **벡터 회전**: 벡터 `v`를 사원수 `q`로 회전시키려면 `v' = qvq⁻¹` (또는 단위 사원수의 경우 `qvq*`) 연산을 사용합니다.
    *   **회전 결합**: 여러 회전을 결합할 때는 사원수 곱셈 순서에 주의해야 합니다. 벡터에 적용되는 순서와 사원수 곱셈 순서는 반대일 수 있습니다.
*   **행렬과의 변환**: 같은 3D 회전 변환을 나타내는 3x3 행렬과 사원수는 서로 변환 가능합니다.
    *   이 책에서는 동차 좌표계와의 일관성을 위해 사원수를 `[x y z w]` 형태로 표기합니다.

### 5.4.5 회전 선형 보간 (Rotational Linear Interpolation)

게임 엔진의 애니메이션 등에서 두 회전 사이의 중간 지점을 찾는 데 사용됩니다.

*   **선형 보간 (LERP)**: 두 사원수 `q₁, q₂` 사이를 간단히 선형 보간하는 방법입니다. 결과는 반드시 정규화해야 합니다.
    *   단점: 사원수가 구면 위에 존재한다는 사실을 제대로 반영하지 못해, 회전 각속도가 일정하지 않을 수 있습니다.
*   **구면 선형 보간 (SLERP)**: LERP의 단점을 보완하며, 4차원 초구의 대원을 따라 보간하여 일정한 각속도를 제공합니다.
    *   **성능 논쟁**: SLERP는 LERP보다 계산이 더 복잡하여 느리다고 알려져 있으나, 구현 방식에 따라 LERP와 성능 차이가 미미할 수 있다는 의견도 있습니다. 실제 사용 시에는 직접 성능을 측정(프로파일링)하여 결정하는 것이 권장됩니다.

---

## 5.5 각 회전 표현 간 비교 (Comparison of Rotation Representations)

회전 변환을 표현하는 여러 방법(오일러 각, 행렬, 회전축+회전각, 사원수)은 각기 장단점이 있어 모든 상황에 맞는 '만능' 표현법은 없습니다.

*   **5.5.1 오일러 각 (Euler Angles)**:
    *   **장점**: 단순하고 작으며(3개 부동소수점), 직관적이고 한 축에 대한 보간이 쉽습니다.
    *   **단점**:
        *   **짐벌 락 (Gimbal Lock)**: 90도 회전 시 두 축이 겹쳐져 자유도를 잃는 현상입니다.
        *   회전 순서에 따라 결과가 달라지므로 고유한 회전 변환을 나타내지 않습니다.
        *   임의의 축에 대한 보간이 어렵습니다.
*   **5.5.2 3x3 행렬 (3x3 Matrices)**:
    *   **장점**: 짐벌 락이 없고, 임의의 회전 변환을 고유하게 표현하며, 점/벡터 회전 변환에 직관적이고 하드웨어 가속이 됩니다. 역행렬 구하기가 빠르며, 다른 아핀 변환과 결합하기 좋습니다.
    *   **단점**: 직관적으로 이해하기 어렵고, 보간하기 힘들며, 오일러 각보다 저장 공간을 더 많이 차지합니다(9개 부동소수점).
*   **5.5.3 회전 축 + 회전 각 (Axis-Angle)**:
    *   **장점**: 직관적이고 저장 공간을 적게 차지합니다(4개 부동소수점).
    *   **단점**: 보간하기 어렵고, 점/벡터 회전 변환에 직접 사용될 수 없으며 행렬이나 사원수로 변환해야 합니다.
*   **5.5.4 사원수 (Quaternions)**:
    *   **장점**: 회전 변환 결합 및 벡터 회전 변환이 가능하며, 보간(SLERP/LERP)이 매우 쉽고, 저장 공간을 적게 차지합니다(4개 부동소수점).
*   **5.5.5 SRT 변환 (SRT Transformation)**:
    *   **정의**: 스케일(S), 회전(R, 사원수), 평행 이동(T, 벡터)을 한데 묶어 아핀 변환을 표현하는 방식입니다.
    *   **장점**: 애니메이션에 널리 쓰이며, 저장 공간이 상대적으로 적고(8~10개 부동소수점), 각 요소(스케일, 평행이동은 LERP, 회전은 SLERP)별로 보간하기 쉽습니다.
*   **5.5.6 이원사원수 (Dual Quaternions)**:
    *   **목적**: 회전과 평행 이동을 모두 포함하는 강체 변환(Rigid Transformation)을 표현합니다.
    *   **장점**: 선형 보간 블렌딩을 상수 시간에, 최단 거리로, 좌표계에 상관없이 처리할 수 있습니다.
    *   **구조**: 각 성분이 실수가 아닌 이원수(dual number)로 구성되며, 두 사원수의 합으로 표기할 수 있습니다.
*   **5.5.7 회전 변환과 자유도 (Rotation Transformation and Degrees of Freedom)**:
    *   **자유도(DOF)**: 물체의 외부 위치와 방향을 고유하게 표현하는 방법의 수를 의미합니다. 3차원 물체는 평행 이동 3자유도, 회전 변환 3자유도를 가집니다 (총 6자유도).
    *   **표현 방식별 자유도**: 오일러 각(3개), 회전축+회전각(4개), 사원수(4개), 3x3 행렬(9개)은 사용하는 부동소수점 개수는 다르지만, 모두 '제약 조건(constraints)'을 통해 결국 3자유도의 회전 변환을 나타냅니다.
        *   예: 회전축+회전각/사원수는 단위 길이 제약조건, 3x3 행렬은 각 행/열이 단위 벡터여야 하는 제약조건이 있습니다.

## 5.6 기타 유용한 수학적 개념 (Other Useful Mathematical Concepts)

*   **5.6.1 직선, 반직선, 선분 (Lines, Rays, Line Segments)**:
    *   **직선**: 시작점 `P₀`에서 단위 벡터 `u` 방향으로 거리 `t`만큼 이동한 점 `P(t) = P₀ + tu`로 표현되는 무한히 긴 선입니다.
    *   **반직선**: 직선에 `t >= 0` 제약조건을 추가한 것으로, 한 방향으로만 뻗어 나갑니다.
    *   **선분**: 양 끝점 `P₀, P₁`에 의해 한정된 직선으로, `t`의 범위를 제한하여 표현합니다.
*   **5.6.2 구 (Spheres)**:
    *   중심 `C`와 반지름 `r`로 정의됩니다. 4차원 벡터 `(Cx, Cy, Cz, r)`로 저장됩니다.
*   **5.6.3 평면 (Planes)**:
    *   평면 위의 한 점 `Pₚ`과 평면에 수직인 법선 벡터 `n`으로 정의됩니다.
    *   방정식: `ax + by + cz + d = 0` 형태로 나타낼 수 있습니다.
    *   **점과 평면 사이의 거리**: `h = ax + by + cz + d`로 계산할 수 있습니다.
    *   저장 방식: `[a b c d]` 4차원 벡터로 간단하고 편리하게 저장됩니다.
    *   **변환**: 법선 벡터 변환과 마찬가지로, 평면을 다른 좌표계로 변환하려면 변환 행렬의 **역전치 행렬**을 적용해야 합니다.
*   **5.6.4 축 정렬 경계 박스 (Axis-Aligned Bounding Box - AABB)**:
    *   각 좌표축에 정렬된 직사각형 박스입니다.
    *   최소/최대 값을 갖는 두 벡터로 표현됩니다 (`Xmin, Ymin, Zmin, Xmax, Ymax, Zmax`).
    *   **용도**: 점이 AABB 안에 있는지 판별하거나, 충돌 감지 시 '조기에 걸러내는' 간단하고 빠른 검사에 자주 사용됩니다.
*   **5.6.5 유향 경계 박스 (Oriented Bounding Box - OBB)**:
    *   내부 물체의 경계에 맞춰 정렬된 직육면체입니다.
    *   주로 물체의 로컬 공간에 정렬되며, 월드 공간에서는 회전되어 있을 수 있습니다.
    *   **용도**: 점이 OBB 안에 있는지 판별할 때는 OBB를 AABB가 정렬된 좌표계로 변환한 후 AABB 검사를 수행하는 방식이 흔합니다.
*   **5.6.6 절두체 (Frustum)**:
    *   머리가 잘린 피라미드 형태를 띠는 6개의 평면으로 구성됩니다.
    *   **용도**: 3D 렌더링에서 가상 카메라 시점으로 보이는 부분을 정의하는 데 사용됩니다.
    *   **구성**: 화면 가장자리를 나타내는 4개 평면과 원/근 클리핑 평면 2개로 이루어집니다.
    *   **검사**: 점이 절두체 안에 있는지 판별하려면 모든 평면의 '안쪽'에 있는지 확인해야 합니다.
*   **5.6.7 볼록 다면체 (Convex Polyhedral Region)**:
    *   임의의 여러 평면으로 이루어진 다면체입니다.
    *   **용도**: 게임에서 다양한 형태의 '트리거 지역'을 정의하는 데 유용합니다.

## 5.7 난수 생성 (Random Number Generation)

게임에서 난수는 매우 광범위하게 사용됩니다.

*   **유사 난수 생성기 (PRNG)**: 컴퓨터는 '진짜' 난수를 생성하는 것이 아니라 복잡하고 결정적인 연속적인 값들을 만들어냅니다. 이를 유사 난수라고 부르며, 이를 생성하는 것을 유사 난수 생성기라고 합니다.
*   **좋은 PRNG의 기준**: 긴 주기, 높은 분포 차원, 엄격한 무작위성 테스트 통과, 빠른 속도 등이 있습니다.
*   **5.7.1 선형 합동 생성기 (Linear Congruential Generators - LCG)**:
    *   **장점**: 빠르고 단순합니다.
    *   **단점**: 일반적으로 품질이 좋지 않아 (주기가 짧고, 통계적 특성 미달) 고품질의 난수가 필요할 때는 권장되지 않습니다.
*   **5.7.2 메르센 트위스터 (Mersenne Twister)**:
    *   LCG의 단점을 개선하고자 고안된 알고리듬입니다.
    *   **장점**: 매우 긴 주기, 높은 분포 차원, 엄격한 무작위성 테스트 통과, 빠릅니다. 게임 엔진에서 흔히 사용됩니다.
*   **5.7.3 마더-오브-올 (Mother-of-All - MOA)**:
    *   조지 마사글리아가 개발한 유사 난수 생성기입니다.
    *   **장점**: 구현이 간단하고 빠르며, 모든 '다이하드 테스트'를 통과하는 고품질의 난수를 생성합니다.
    *   마사글리아는 다른 난수 생성기가 필요 없을 것이라고 자신감을 표현했습니다.
    *   관련 알고리듬으로 KISS (긴 주기, 테스트 통과)와 Xorshift (더 빠르나 품질 약간 낮음)가 있습니다.
*   **5.7.4 PCG (Permutation Congruential Generator)**:
    *   인기 있고 품질이 높은 유사 난수 생성기 계열입니다.
    *   합동 생성기와 순열 함수를 조합하여 출력 값을 만듭니다.