## 3장: 게임을 위한 소프트웨어 엔지니어링 기초
수에 대한 기초와 표현법에 대해 살펴보고, 널리 쓰이는 컴퓨터 및 CPU 구성 요소와 구조, 기계어와 어셈블리 언어, C++ 프로그래밍 언어에 대해서 알아본다.

### 3.1 C++ 개념과 올바른 사용법

#### 3.1.1 객체지향 프로그래밍에 대한 간단한 개념

- 클래스와 객체
- 캡슐화
- 상속
- 다형성
- 합성과 집한
- 디자인 패턴

#### 3.1.2 C++ 표준화화
해당 장에서는 C++의 역사에 따라서 중요한 변경점을 설명한다. 자세한 내용은 직접 읽어보는 것이 좋다(내 의견).

##### 3.1.2.2 언어의 어떤 기능을 술 것인가?
C++의 추가된 기능을 봤을 때, 당연히 이 모든 것을 엔진이나 게임에 쓰고 싶을 것이다. 그러나 당장 그 기술들을 쓸 필요는 없다.
너티 독에서는 언어의 새 기능을 도입할 때 보수적으로 접근했다.

#### 3.1.3 코딩 규칙: 필요한 이유와 적용 정도
필요성은 다음과 같다.
1. 특정 규칙을 준수하면 코드를 읽고 이해하기 쉬워지며 유지 비용도 적게 든다.
2. 터무니 없는 실수를 줄일 수 있다.

글쓴이가 생각하는 중요한 규칙은 아래와 같다.
- 인터페이스를 중시할 것
- 이름을 잘 지을 것
- 전역 네임스페이스를 깔금하게 유지할 것
- 널리 알려진 C++ 사용법을 따를 것
- 코딩 규칙은 일관돼야 할 것
- 오류를 스스로 드러내는 코드를 작성할 것

### 3.2 에러 감지와 처리

#### 3.2.3 에러 감지와 에러 처리 구현
프로그래밍에서 에러 감지와 처리 방법을 살펴본다.

##### 3.2.3.1 에러 리턴 코드
- 함수에서 에러를 감지하면 특정 에러 코드를 반환하는 방식.
- 불리언 값 반환: 성공(true) 또는 실패(false)로 표현.
- 음의 값 반환: 정상적인 값이 양수일 때, 음수를 에러 코드로 활용.
- 열거형 반환: 여러 개의 에러 상태를 정의하여 보다 정확한 원인 제공.
   - 예) enum Error { kSuccess, kAssetNotFound, kInvalidRange, ... }
- 리턴된 에러 코드를 적절히 처리해야 하며, 그대로 호출한 함수에 전달할 수도 있다.
##### 3.2.3.2 예외 처리
- 리턴 코드 방식의 한계: 에러를 처음 감지한 함수에서 처리하기 어려울 수 있음.
  - 예) 게임 루프에서만 에러 처리가 가능한 경우, 여러 함수가 중간에 개입하면 전달이 복잡해짐.
- 예외 처리(exception handling):
  - C++에서 제공하는 기능으로, 예외를 던지고(throw) try-catch 블록에서 처리.
  - 예외 객체를 활용하여 오류 정보를 포함한 상태 전달 가능.
  - try 블록에서 예외가 발생하면, 적절한 catch 블록이 실행되며 자원 해제 등이 자동 수행됨.

- 예외 처리의 장점과 단점  
✅ 장점:

  - 코드가 깔끔하게 분리됨.
  - 특정 영역에서만 예외 처리를 사용 가능.
  - 예외가 발생해도 함수들이 스택을 따라 정리됨(stack unwinding).
  
  ❌ 단점:

  - 성능 저하 가능 (스택 프레임 관리 비용 증가).
  - 전체 프로그램에서 예외를 다룰 방법이 명확해야 함.
  - 예외가 던져질 때 어떤 스택이 호출될지 예측 어려움.
  - 일부 라이브러리는 예외 처리를 사용하지 않음 (예: NASA, JPL, 게임 엔진 등).
- 게임 엔진에서 예외 처리의 논쟁  
많은 게임 엔진에서는 예외 처리를 사용하지 않음.
마이크 액튼(Mike Acton)과 Insomniac Games의 엔진 디렉터들이 예외 사용을 피할 것을 권장.
임베디드 소프트웨어(NASA 등)에서도 미션 크리티컬한 환경에서는 예외 사용을 지양.
예외 처리를 쓰면 유지보수성이 증가하지만, 성능과 예측 가능성이 저하될 수 있음.

- RAII(Resource Acquisition Is Initialization)와 예외 처리
RAII 패턴: 객체 생성 시 자원을 확보하고, 소멸자에서 자원을 정리하는 방식.
예외와 함께 사용하면 자원 관리가 쉬워짐.
하지만 예외 없이도 활용 가능:
객체를 생성한 후 상태를 검사하여 실패 여부를 확인하는 방식으로도 대체 가능.
예외를 던지지 않아도 RAII의 장점을 살릴 수 있음.

##### 3.2.3.3 어서션

assertion은 어 떤 코드의 논리적 기반이 되는 어쩐 전제를 실수로 침범하는 일을 방지한다. 왜냐하면 그 전제를 침법하는 순간 바로 터지는 지뢰와 같기 때문이다.

### 3.3 데이터, 코드, 메모리 레이아웃
#### 3.3.1 수 표현
컴퓨터 공학에서 대부분의 마이크로프로세서는 음의 정수를 표현하기 위해 '2의 보수' 방법을 사용한다.

##### 3.3.1.3 고정소수점 표현법

정수부분을 나타내는 비트와 소수부분을 나타낼 비트를 정해두고 사용한다.

##### 3.3.1.4 부동소수점 표현법

부동소수는 정수와 소수를 합친 가수와 가수 안에서 소수점이 어디 위치할지 나타내는 지수 그리고 부호 비트 이렇게 세 부분으로 이뤄진다.
부동소수의 정확도는 절대값이 작을수록 높아진다.
- ULP: 2개의 부동소수가 있는데, 가수의 가장 낮은 유효 숫자의 값을 제외하고는 모두 같다고 하자. 이 때 두 값은 1ULP(Unit in the Last Place)의 차가 있다고 말한다.
**p160할차례**