## 3장: 게임을 위한 소프트웨어 엔지니어링 기초
수에 대한 기초와 표현법에 대해 살펴보고, 널리 쓰이는 컴퓨터 및 CPU 구성 요소와 구조, 기계어와 어셈블리 언어, C++ 프로그래밍 언어에 대해서 알아본다.

### 3.1 C++ 개념과 올바른 사용법

#### 3.1.1 객체지향 프로그래밍에 대한 간단한 개념

- 클래스와 객체
- 캡슐화
- 상속
- 다형성
- 합성과 집한
- 디자인 패턴

#### 3.1.2 C++ 표준화화
해당 장에서는 C++의 역사에 따라서 중요한 변경점을 설명한다. 자세한 내용은 직접 읽어보는 것이 좋다(내 의견).

##### 3.1.2.2 언어의 어떤 기능을 술 것인가?
C++의 추가된 기능을 봤을 때, 당연히 이 모든 것을 엔진이나 게임에 쓰고 싶을 것이다. 그러나 당장 그 기술들을 쓸 필요는 없다.
너티 독에서는 언어의 새 기능을 도입할 때 보수적으로 접근했다.

#### 3.1.3 코딩 규칙: 필요한 이유와 적용 정도
필요성은 다음과 같다.
1. 특정 규칙을 준수하면 코드를 읽고 이해하기 쉬워지며 유지 비용도 적게 든다.
2. 터무니 없는 실수를 줄일 수 있다.

글쓴이가 생각하는 중요한 규칙은 아래와 같다.
- 인터페이스를 중시할 것
- 이름을 잘 지을 것
- 전역 네임스페이스를 깔금하게 유지할 것
- 널리 알려진 C++ 사용법을 따를 것
- 코딩 규칙은 일관돼야 할 것
- 오류를 스스로 드러내는 코드를 작성할 것

### 3.2 에러 감지와 처리

#### 3.2.3 에러 감지와 에러 처리 구현
프로그래밍에서 에러 감지와 처리 방법을 살펴본다.

##### 3.2.3.1 에러 리턴 코드
- 함수에서 에러를 감지하면 특정 에러 코드를 반환하는 방식.
- 불리언 값 반환: 성공(true) 또는 실패(false)로 표현.
- 음의 값 반환: 정상적인 값이 양수일 때, 음수를 에러 코드로 활용.
- 열거형 반환: 여러 개의 에러 상태를 정의하여 보다 정확한 원인 제공.
   - 예) enum Error { kSuccess, kAssetNotFound, kInvalidRange, ... }
- 리턴된 에러 코드를 적절히 처리해야 하며, 그대로 호출한 함수에 전달할 수도 있다.
##### 3.2.3.2 예외 처리
- 리턴 코드 방식의 한계: 에러를 처음 감지한 함수에서 처리하기 어려울 수 있음.
  - 예) 게임 루프에서만 에러 처리가 가능한 경우, 여러 함수가 중간에 개입하면 전달이 복잡해짐.
- 예외 처리(exception handling):
  - C++에서 제공하는 기능으로, 예외를 던지고(throw) try-catch 블록에서 처리.
  - 예외 객체를 활용하여 오류 정보를 포함한 상태 전달 가능.
  - try 블록에서 예외가 발생하면, 적절한 catch 블록이 실행되며 자원 해제 등이 자동 수행됨.

- 예외 처리의 장점과 단점  
✅ 장점:

  - 코드가 깔끔하게 분리됨.
  - 특정 영역에서만 예외 처리를 사용 가능.
  - 예외가 발생해도 함수들이 스택을 따라 정리됨(stack unwinding).
  
  ❌ 단점:

  - 성능 저하 가능 (스택 프레임 관리 비용 증가).
  - 전체 프로그램에서 예외를 다룰 방법이 명확해야 함.
  - 예외가 던져질 때 어떤 스택이 호출될지 예측 어려움.
  - 일부 라이브러리는 예외 처리를 사용하지 않음 (예: NASA, JPL, 게임 엔진 등).
- 게임 엔진에서 예외 처리의 논쟁  
많은 게임 엔진에서는 예외 처리를 사용하지 않음.
마이크 액튼(Mike Acton)과 Insomniac Games의 엔진 디렉터들이 예외 사용을 피할 것을 권장.
임베디드 소프트웨어(NASA 등)에서도 미션 크리티컬한 환경에서는 예외 사용을 지양.
예외 처리를 쓰면 유지보수성이 증가하지만, 성능과 예측 가능성이 저하될 수 있음.

- RAII(Resource Acquisition Is Initialization)와 예외 처리
RAII 패턴: 객체 생성 시 자원을 확보하고, 소멸자에서 자원을 정리하는 방식.
예외와 함께 사용하면 자원 관리가 쉬워짐.
하지만 예외 없이도 활용 가능:
객체를 생성한 후 상태를 검사하여 실패 여부를 확인하는 방식으로도 대체 가능.
예외를 던지지 않아도 RAII의 장점을 살릴 수 있음.

##### 3.2.3.3 어서션

assertion은 어 떤 코드의 논리적 기반이 되는 어쩐 전제를 실수로 침범하는 일을 방지한다. 왜냐하면 그 전제를 침법하는 순간 바로 터지는 지뢰와 같기 때문이다.

### 3.3 데이터, 코드, 메모리 레이아웃
#### 3.3.1 수 표현
컴퓨터 공학에서 대부분의 마이크로프로세서는 음의 정수를 표현하기 위해 '2의 보수' 방법을 사용한다.

##### 3.3.1.3 고정소수점 표현법

정수부분을 나타내는 비트와 소수부분을 나타낼 비트를 정해두고 사용한다.

##### 3.3.1.4 부동소수점 표현법

부동소수는 정수와 소수를 합친 가수와 가수 안에서 소수점이 어디 위치할지 나타내는 지수 그리고 부호 비트 이렇게 세 부분으로 이뤄진다.
부동소수의 정확도는 절대값이 작을수록 높아진다.
- ULP: 2개의 부동소수가 있는데, 가수의 가장 낮은 유효 숫자의 값을 제외하고는 모두 같다고 하자. 이 때 두 값은 1ULP(Unit in the Last Place)의 차가 있다고 말한다.


##### 3.3.2.1 멀티바이트 데이터와 엔디언

- 리틀 엔디언: LSB(Least Significant Byte)가 MSB(Most Significant Byte)보다 낮은 메모리 주소에 저장되는 방법이다.
- 빅 엔디언: MSB(Most Significant Byte)가 LSB(Least Significant Byte)보다 낮은 메모리 주소에 저장되는 방법이다.

#### 3.3.3 킬로바이트 vs 키비바이트

- 킬로바이트(kB) : 기존 10진법 단위로 되어있는 단위 표시계, 1000바이트
- 키비바이트(KB) : 2진법 단위로 되어있는 단위 표시계, 1024바이트

#### 3.3.4 선언, 정의 연결성

- 선언: 데이터 객체나 함수의 형태를 나타낸다. 컴퍼일러에 `이름`과 데이터 타입 또는 함수의 서명을 알려준다.
- 정의: 프로그램 안에 고유한 저장 공간을 나타낸다. 이 저장 공간 안에는 변수, 구조체 및 클래스의 인스턴스, 함수의 기계어 등이 들어갈 수 있다.

##### 3.3.4.3 연결성(Linkage)의 개념
C/C++에서 모든 정의(Definition) 는 연결성을 가진다.
연결성이란, 변수나 함수가 다른 번역 단위(Translation Unit)에서도 참조될 수 있는지 여부를 나타내는 개념이다.

- 외부 연결성(External Linkage)  
정의된 번역 단위뿐만 아니라 다른 번역 단위에서도 사용 가능한 변수나 함수.
기본적으로 모든 전역 변수와 함수는 외부 연결성을 가진다.
extern 키워드를 사용하면 다른 .cpp 파일에서 참조 가능하다.
- 내부 연결성(Internal Linkage)  
정의된 번역 단위(파일) 내에서만 사용 가능한 변수나 함수.
static 키워드를 사용하면 내부 연결성을 갖는다.
다른 .cpp 파일에서도 동일한 이름의 변수를 정의해도 충돌하지 않는다.
클래스에서 private: 접근 지정자와 비슷한 개념으로 볼 수 있음.

- 중요한 개념
  - static이 붙은 변수나 함수는 해당 번역 단위(파일) 내에서만 사용 가능하다.
  - extern을 사용하면 다른 번역 단위에서 선언된 변수를 참조할 수 있다.
  - static이 붙은 함수는 해당 파일에서만 호출 가능하다.
  - 인라인 함수(inline function)의 경우, 헤더에서 정의될 때 기본적으로 내부 연결성을 가진다(static처럼 동작). 여러 .cpp 파일에서 포함되더라도, 각 번역 단위에서 별도의 함수 복사본이 생성되므로 충돌하지 않는다.


#### 3.3.5 C/C++ 프로그램의 메모리 구조
C/C++ 프로그램의 실행 파일은 메모리에 여러 세그먼트로 나뉘어 올라간다. 주요 세그먼트는 다음과 같다.

1. 텍스트 세그먼트 (Text Segment)
    - 코드 세그먼트라고도 불림.
프로그램의 모든 함수 기계어를 포함.
2. 데이터 세그먼트 (Data Segment)
    - 초기값이 있는 전역 및 정적 변수 저장.
실행 시 메모리에 배치되며, 지정된 초기값으로 설정됨.
3. BSS 세그먼트 (Block Started by Symbol)
    - 초기화되지 않은 전역 및 정적 변수 저장.
    - C/C++에서는 자동으로 0으로 초기화됨.
4. 읽기 전용 데이터 세그먼트 (Read-only Data Segment)
    - const 상수, 부동소수점 상수 등이 저장됨.
    - 기계어 코드 내 삽입되는 경우도 있음.


- 추가 개념  
전역 변수는 초기화 여부에 따라 데이터 세그먼트 또는 BSS 세그먼트에 저장됨.
static 키워드를 사용하면 정적 변수로서 특정 범위에서만 사용 가능하지만, 메모리 구조적으로는 전역 변수와 동일하게 취급됨.
함수 내부의 static 변수는 해당 함수가 처음 호출될 때 초기화됨.

##### 3.3.5.2 프로그램 스택

함수가 불릴 때마다 스택 메모리 안의 연속된 공간이 스택 위로 마련되며, 이것을 스택에 푸시한다고 말한다. 그리고 이런 메모리블록을 스택 프레임 이라고 한다. 스택 프레임에는 세 가지 종류의 데이터가 저장된다.
1. 리턴 주소  
2. CPU 레지스터  
3. 지역 변수

##### 3.3.5.3 동적 할당 힙

#### 3.3.6 멤버 변수

선언만으로는 메로리 할당이 이뤄지지 않는다. 정의가 되는 것들만 메모리 할당이 이루어진다.

#### 3.3.7 메모리상의 객체구조

데이터 구조를 선언할 때 미리 메모리 정렬과 패킹을 염두에 두는 것은 좋을 습관이다.

##### 3.3.7.2 C++ 클래스의 메모리 구조
C++에서는 상속과 가상 함수 때문에 C 구조체와 조금 다르다.
클래스나 베이스 클래스에 가상 함수가 있는경우 4바이트(대상 플랫폼이 64비트인 경우 8바이트)가 클래스 구조에 추가 되고, 대개 클래스의 제일 앞에 위치한다. 이 4혹은 8바이트는 vpointer라고 불린, 이는 vtable이라고 불리는 자료 구조를 가르키는 포인터가 있기 때문이다.

### 3.4 컴퓨터 하드웨어 기초  
언어가 고수준일수록 코드가 구동되는 하드웨어의 세부 사항으로부터 멀어진다. 하드웨어 구조에 대한 이해는 코드 최적화에 도움이 된다. 또한 병렬 프로그래밍에도 필수적이다.

#### 3.4.1 비교적 단순한 구세대 컴퓨터를 통해 배우기
구세대 컴퓨터는 단순한 CPU 구조를 가지고 있기 때문에 컴퓨터의 구조에 대해 이해하는데 많은 도움이 된다.  
- 마이클 애브라시의 Graphics Programming Black Book

#### 3.4.2 컴퓨터의 구조
컴퓨터 구조를 가장 단순하게 생각하면 중앙 처리 장치(CPU)와 여러 열(bank)의 메모리가 마더보드에 있고, 이 둘이 하나 이상의 버스를 통해 연결되며, I/O 포트 또는 확장 슬롯을 통해 외부 주변 장치와 연결되는 것이다.

#### 3.4.3 CPU
- 수리/논리 장치(ALU)
- 부동소수 장치(FPU)
- 벡터 처리 장치(VPU)
- 메모리 컨트롤러(MC) 또는 메모리 관리 장치(MMU) : 칩 내부 또는 외부의 메모리 장치와의 인터페이스를 처리한다.
- 레지스터 : 임시 저장소
- 제어 장치(CU) 

이 모든 것을 구동하는 것이 클럭이다. 클럭의 진동수에 따라 명령어를 처리하거나 계산을 하는 등의 CPU의 동작이 얼마나 빨리 수행되는지 결정된다.

##### 3.4.3.1 ALU

##### 3.4.3.2 VPU
오늘날의 CPU는 FPU가 없고 VPU가 이를 대체한다. 벡터 처리는 SIMD라고도 불리는데, 하나의 수리 연산자가 여러 짝의 입력에 동시에 수행되기 때문이다.

##### 3.4.3.3 레지스터
p.194 차례